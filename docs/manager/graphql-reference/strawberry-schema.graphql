type Artifact implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  type: ArtifactType!
  status: ArtifactStatus!
  description: String
  registry: SourceInfo!
  source: SourceInfo!
  size: HumanReadableNumber!
  createdAt: DateTime!
  updatedAt: DateTime!
  version: String!
}

type ArtifactConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ArtifactEdge!]!
  totalCount: Int!
}

"""An edge in a connection."""
type ArtifactEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Artifact!
}

input ArtifactFilter {
  type: [ArtifactType!] = null
  status: [ArtifactStatus!] = null
  name: StringFilter = null
  registry: StringFilter = null
  source: StringFilter = null
  AND: ArtifactFilter = null
  OR: ArtifactFilter = null
  NOT: ArtifactFilter = null
  DISTINCT: Boolean = null
}

type ArtifactGroup implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  type: ArtifactType!
  status: ArtifactStatus!
  description: String
  artifacts(filter: ArtifactFilter = null, orderBy: [ArtifactOrderBy!] = null, before: String = null, after: String = null, first: Int = null, last: Int = null): ArtifactConnection!
}

"""A connection to a list of items."""
type ArtifactGroupConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ArtifactGroupEdge!]!
}

"""An edge in a connection."""
type ArtifactGroupEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ArtifactGroup!
}

input ArtifactOrderBy {
  field: ArtifactOrderField!
  direction: OrderDirection! = ASC
}

enum ArtifactOrderField {
  ID
  NAME
  TYPE
  SIZE
  CREATED_AT
  UPDATED_AT
  LATEST_VERSION
}

enum ArtifactStatus {
  AVAILABLE
  PULLING
  VERIFYING
  VERIFIED
  INSTALLING
  INSTALLED
  FAILED
}

enum ArtifactType {
  MODEL
  PACKAGE
  IMAGE
}

type CancelPullPayload {
  artifact: Artifact
}

"""Date with time (isoformat)"""
scalar DateTime

input DeleteArtifactInput {
  artifactId: ID!
  version: String!
  forceDelete: Boolean! = false
}

type DeleteArtifactPayload {
  artifact: Artifact
}

type DownloadProgress {
  artifactId: ID!
  progress: Float!
  status: ArtifactStatus!
}

scalar HumanReadableNumber

input InstallArtifactInput {
  artifactId: ID!
  version: String!
}

type InstallArtifactPayload {
  artifact: Artifact
}

type Mutation {
  pullArtifact(input: PullArtifactInput!): PullArtifactPayload!
  installArtifact(input: InstallArtifactInput!): InstallArtifactPayload!
  updateArtifact(input: UpdateArtifactInput!): UpdateArtifactPayload!
  deleteArtifact(input: DeleteArtifactInput!): DeleteArtifactPayload!
  verifyArtifact(artifactId: ID!, version: String = null): VerifyArtifactPayload!
  cancelPull(artifactId: ID!): CancelPullPayload!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: ID!
}

enum OrderDirection {
  ASC
  DESC
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

input PullArtifactInput {
  artifactId: ID!
  version: String!
}

type PullArtifactPayload {
  artifact: Artifact
}

type Query {
  artifacts(filter: ArtifactFilter = null, orderBy: [ArtifactOrderBy!] = null, first: Int = null, after: String = null): ArtifactConnection!
  artifactGroups(filter: ArtifactFilter = null, orderBy: [ArtifactOrderBy!] = null, before: String = null, after: String = null, first: Int = null, last: Int = null): ArtifactGroupConnection!
  artifact(id: ID!): Artifact
  artifactGroup(id: ID!): ArtifactGroup
}

type SourceInfo {
  name: String
  url: String
}

input StringFilter {
  contains: String = null
  startsWith: String = null
  endsWith: String = null
  equals: String = null
  notEquals: String = null
}

type Subscription {
  artifactStatusChanged(artifactId: ID = null): Artifact!
  downloadProgress(artifactId: ID!): DownloadProgress!
}

input UpdateArtifactInput {
  artifactId: ID!
  targetVersion: String!
}

type UpdateArtifactPayload {
  artifact: Artifact
}

type VerifyArtifactPayload {
  artifact: Artifact
}