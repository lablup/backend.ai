schema @link(url: "https://specs.apollo.dev/federation/v2.7", import: ["@external", "@key", "@shareable"]) {
  query: Queries
  mutation: Mutation
  subscription: Subscription
}

type Artifact implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  type: ArtifactType!
  description: String
  registry: SourceInfo!
  source: SourceInfo!
  size: ByteSize!
}

type ArtifactConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ArtifactEdge!]!
  count: Int!
}

"""An edge in a connection."""
type ArtifactEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Artifact!
}

input ArtifactFilter {
  type: [ArtifactType!] = null
  status: ArtifactStatusFilter = null
  name: StringFilter = null
  registry: StringFilter = null
  source: StringFilter = null
  AND: ArtifactFilter = null
  OR: ArtifactFilter = null
  NOT: ArtifactFilter = null
  DISTINCT: Boolean = null
}

type ArtifactImportProgressUpdatedPayload {
  artifactId: ID!
  progress: Float!
  status: ArtifactStatus!
}

input ArtifactOrderBy {
  field: ArtifactOrderField!
  direction: OrderDirection! = ASC
}

enum ArtifactOrderField {
  NAME
  TYPE
  SIZE
}

type ArtifactRevision implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  status: ArtifactStatus!
  createdAt: DateTime!
  updatedAt: DateTime!
  readme: String!
  version: String!
  size: ByteSize!
}

type ArtifactRevisionConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ArtifactRevisionEdge!]!
  count: Int!
}

"""An edge in a connection."""
type ArtifactRevisionEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ArtifactRevision!
}

input ArtifactRevisionFilter {
  status: [ArtifactStatus!] = null
  version: StringFilter = null
  artifactId: ID = null
  AND: ArtifactRevisionFilter = null
  OR: ArtifactRevisionFilter = null
  NOT: ArtifactRevisionFilter = null
  DISTINCT: Boolean = null
}

input ArtifactRevisionOrderBy {
  field: ArtifactRevisionOrderField!
  direction: OrderDirection! = ASC
}

enum ArtifactRevisionOrderField {
  VERSION
  SIZE
  CREATED_AT
  UPDATED_AT
}

enum ArtifactStatus {
  SCANNED
  PULLED
  PULLING
  VERIFYING
  NEEDS_APPROVAL
  AVAILABLE
  FAILED
}

input ArtifactStatusChangedInput {
  artifactIds: [ID!]!
}

type ArtifactStatusChangedPayload {
  artifact: Artifact!
}

input ArtifactStatusFilter {
  IN: [ArtifactStatus!] = null
  EQ: [ArtifactStatus!] = null
}

input ArtifactTarget {
  artifactId: ID!
  revision: String!
}

input ArtifactTarget {
  artifactId: ID!
  revision: String!
}

enum ArtifactType {
  MODEL
  PACKAGE
  IMAGE
}

input AuthorizeArtifactInput {
  artifactId: ID!
}

type AuthorizeArtifactPayload {
  artifact: Artifact!
}

scalar ByteSize

type CancelImportArtifactPayload {
  artifactId: ID!
}

type ClusterConfig {
  mode: ClusterMode!
  size: Int!
}

input ClusterConfigInput {
  mode: ClusterMode!
  size: Int!
}

enum ClusterMode {
  SINGLE_NODE
  MULTI_NODE
}

input CreateHuggingFaceRegistryInput {
  url: String!
  name: String!
  token: String = null
}

type CreateHuggingFaceRegistryPayload {
  huggingfaceRegistry: HuggingFaceRegistry!
}

input CreateModelDeploymentInput {
  metadata: ModelDeploymentMetadataInput!
  networkAccess: ModelDeploymentNetworkAccessInput!
  clusterConfig: ClusterConfigInput!
  resourceConfig: ResourceConfigInput!
  deploymentStrategy: DeploymentStrategyInput!
  initialRevision: CreateModelRevisionInput!
}

type CreateModelDeploymentPayload {
  deployment: ModelDeployment!
}

input CreateModelRevisionInput {
  deploymentId: ID!
  name: String!
  image: ImageInput!
  modelRuntimeConfig: ModelRuntimeConfigInput!
  modelMountConfig: ModelMountConfigInput!
}

type CreateModelRevisionPayload {
  revision: ModelRevision!
}

input CreateObjectStorageInput {
  name: String!
  host: String!
  accessKey: String!
  secretKey: String!
  endpoint: String!
  region: String!
}

type CreateObjectStoragePayload {
  objectStorage: ObjectStorage!
}

"""Date with time (isoformat)"""
scalar DateTime

input DeleteArtifactInput {
  artifactId: ID!
}

type DeleteArtifactPayload {
  artifactId: ID!
}

input DeleteHuggingFaceRegistryInput {
  id: ID!
}

type DeleteHuggingFaceRegistryPayload {
  id: ID!
}

input DeleteModelDeploymentInput {
  id: ID!
}

type DeleteModelDeploymentPayload {
  deployment: ModelDeployment
}

input DeleteObjectStorageInput {
  id: ID!
}

type DeleteObjectStoragePayload {
  id: ID!
}

input DeploymentFilter {
  status: DeploymentStatus = null
  openToPublic: Boolean = null
  tags: [StringFilter!] = null
  AND: DeploymentFilter = null
  OR: DeploymentFilter = null
  NOT: DeploymentFilter = null
  DISTINCT: Boolean = null
}

input DeploymentOrderBy {
  field: DeploymentOrderField!
  direction: OrderDirection! = DESC
}

enum DeploymentOrderField {
  CREATED_AT
  UPDATED_AT
  NAME
}

enum DeploymentStatus {
  ACTIVE
  INACTIVE
}

type DeploymentStatusChangedPayload {
  deployment: ModelDeployment!
}

type DeploymentStrategy {
  type: DeploymentStrategyType!
}

input DeploymentStrategyInput {
  type: DeploymentStrategyType!
}

enum DeploymentStrategyType {
  ROLLING
  BLUE_GREEN
  CANARY
}

extend type EndpointAutoScalingRuleNode @key(fields: "id") {
  id: ID! @external
}

extend type EndpointToken @key(fields: "token") {
  token: String! @external
}

input GetPresignedDownloadURLInput {
  artifactId: ID!
  storageId: ID!
  bucketName: String!
  key: String!
}

type GetPresignedDownloadURLPayload {
  presignedUrl: String!
}

input GetPresignedUploadURLInput {
  storageId: ID!
  bucketName: String!
  key: String!
  contentType: String = null
  expiration: Int = null
  minSize: Int = null
  maxSize: Int = null
}

type GetPresignedUploadURLPayload {
  presignedUrl: String!
  fields: String!
}

type HuggingFaceRegistry implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  url: String!
  name: String!
  token: String
}

type HuggingFaceRegistryConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [HuggingFaceRegistryEdge!]!
  count: Int!
}

"""An edge in a connection."""
type HuggingFaceRegistryEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: HuggingFaceRegistry!
}

input ImageInput {
  name: String!
  architecture: String!
}

extend type ImageNode @key(fields: "id") {
  id: ID! @external
}

input ImportArtifactsInput {
  artifacts: [ArtifactTarget!]!
  storageId: ID!
  bucketName: String!
}

type ImportArtifactsPayload {
  artifacts: ArtifactConnection!
}

"""A custom scalar for JSON strings using orjson"""
scalar JSONString

type ModelDeployment implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  metadata: ModelDeploymentMetadata!
  networkAccess: ModelDeploymentNetworkAccess!
  revision: ModelRevision
  revisionHistory: ModelRevisionConnection!
  scalingRule: ScalingRule!
  replicaState: ReplicaState!
  deploymentStrategy: DeploymentStrategy!
  clusterConfig: ClusterConfig!
  resourceConfig: ResourceConfig!
  createdUser: UserNode!
}

type ModelDeploymentConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ModelDeploymentEdge!]!
  count: Int!
}

"""An edge in a connection."""
type ModelDeploymentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ModelDeployment!
}

type ModelDeploymentMetadata {
  name: String!
  status: DeploymentStatus!
  tags: [String!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ModelDeploymentMetadataInput {
  name: String!
  tags: [String!] = null
}

type ModelDeploymentNetworkAccess {
  endpointUrl: String
  preferredDomainName: String
  openToPublic: Boolean!
  accessTokens: [EndpointToken!]!
}

input ModelDeploymentNetworkAccessInput {
  preferredDomainName: String = null
  openToPublic: Boolean! = false
}

type ModelMountConfig {
  vfolder: VirtualFolderNode!
  mountDestination: String!
  definitionPath: String!
}

input ModelMountConfigInput {
  vfolderId: ID!
  mountDestination: String!
  definitionPath: String!
}

type ModelReplica implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  status: ReplicaStatus!
  revision: ModelRevision!
  routings: [RoutingNode!]!
}

type ModelReplicaConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ModelReplicaEdge!]!
  count: Int!
}

"""An edge in a connection."""
type ModelReplicaEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ModelReplica!
}

type ModelRevision implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  modelRuntimeConfig: ModelRuntimeConfig!
  modelMountConfig: ModelMountConfig!
  image: ImageNode!
  createdAt: DateTime!
}

type ModelRevisionConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ModelRevisionEdge!]!
  count: Int!
}

"""An edge in a connection."""
type ModelRevisionEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ModelRevision!
}

input ModelRevisionFilter {
  name: StringFilter = null
  deploymentId: ID = null
  AND: ModelRevisionFilter = null
  OR: ModelRevisionFilter = null
  NOT: ModelRevisionFilter = null
  DISTINCT: Boolean = null
}

input ModelRevisionOrder {
  field: ModelRevisionOrderField!
  direction: OrderDirection! = DESC
}

enum ModelRevisionOrderField {
  CREATED_AT
  NAME
}

type ModelRuntimeConfig {
  runtimeVariant: String!
  serviceConfig: ServiceConfig
  environ: JSONString
}

input ModelRuntimeConfigInput {
  runtimeVariant: String!
  serviceConfig: JSONString = null
  environ: JSONString = null
}

type Mutation {
  scanArtifacts(input: ScanArtifactInput!): ScanArtifactsPayload!
  importArtifacts(input: ImportArtifactsInput!): ImportArtifactsPayload!
  updateArtifact(input: UpdateArtifactInput!): UpdateArtifactPayload!
  deleteArtifact(input: DeleteArtifactInput!): DeleteArtifactPayload!
  cancelImportArtifact(artifactId: ID!): CancelImportArtifactPayload!
  createModelDeployment(input: CreateModelDeploymentInput!): CreateModelDeploymentPayload!
  updateModelDeployment(input: UpdateModelDeploymentInput!): UpdateModelDeploymentPayload!
  deleteModelDeployment(input: DeleteModelDeploymentInput!): DeleteModelDeploymentPayload!
  createModelRevision(input: CreateModelRevisionInput!): CreateModelRevisionPayload!
  createObjectStorage(input: CreateObjectStorageInput!): CreateObjectStoragePayload!
  updateObjectStorage(input: UpdateObjectStorageInput!): UpdateObjectStoragePayload!
  deleteObjectStorage(input: DeleteObjectStorageInput!): DeleteObjectStoragePayload!
  createHuggingfaceRegistry(input: CreateHuggingFaceRegistryInput!): CreateHuggingFaceRegistryPayload!
  updateHuggingfaceRegistry(input: UpdateHuggingFaceRegistryInput!): UpdateHuggingFaceRegistryPayload!
  deleteHuggingfaceRegistry(input: DeleteHuggingFaceRegistryInput!): DeleteHuggingFaceRegistryPayload!
  getPresignedDownloadUrl(input: GetPresignedDownloadURLInput!): GetPresignedDownloadURLPayload!
  getPresignedUploadUrl(input: GetPresignedUploadURLInput!): GetPresignedUploadURLPayload!
  authorizeArtifact(input: AuthorizeArtifactInput!): AuthorizeArtifactPayload!
  unauthorizeArtifact(input: UnauthorizeArtifactInput!): UnauthorizeArtifactPayload!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: ID!
}

type ObjectStorage implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  name: String!
  host: String!
  accessKey: String!
  secretKey: String!
  endpoint: String!
  region: String!
}

type ObjectStorageConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ObjectStorageEdge!]!
  count: Int!
}

"""An edge in a connection."""
type ObjectStorageEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ObjectStorage!
}

enum OrderDirection {
  ASC
  DESC
}

"""Information to aid in pagination."""
type PageInfo @shareable {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Queries {
  _entities(representations: [_Any!]!): [_Entity]!
  _service: _Service!
  artifact(id: ID!): Artifact
  artifacts(filter: ArtifactFilter = null, orderBy: [ArtifactOrderBy!] = null, before: String = null, after: String = null, first: Int = null, last: Int = null, limit: Int = null, offset: Int = null): ArtifactConnection!
  artifactRevision(id: ID!): ArtifactRevision
  artifactRevisions(filter: ArtifactRevisionFilter = null, orderBy: [ArtifactRevisionOrderBy!] = null, before: String = null, after: String = null, first: Int = null, last: Int = null, limit: Int = null, offset: Int = null): ArtifactRevisionConnection!
  deployments(
    filter: DeploymentFilter = null
    orderBy: DeploymentOrderBy = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ModelDeploymentConnection!
  deployment(id: ID!): ModelDeployment
  revisions(
    filter: ModelRevisionFilter = null
    order: ModelRevisionOrder = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
  ): ModelRevisionConnection!
  revision(id: ID!): ModelRevision
  replica(id: ID!): ModelReplica
  objectStorage(id: ID!): ObjectStorage
  objectStorages(before: String = null, after: String = null, first: Int = null, last: Int = null, limit: Int = null, offset: Int = null): ObjectStorageConnection!
  huggingfaceRegistry(id: ID!): HuggingFaceRegistry
  huggingfaceRegistries(before: String = null, after: String = null, first: Int = null, last: Int = null, offset: Int = null, limit: Int = null): HuggingFaceRegistryConnection!
}

type RawServiceConfig {
  config: JSONString!
  extraCliParameters: String
}

type ReplicaState {
  desiredReplicaCount: Int!
  replicas: ModelReplicaConnection!
}

enum ReplicaStatus {
  HEALTHY
  UNHEALTHY
}

type ReplicaStatusChangedPayload {
  replica: ModelReplica!
}

type ResourceConfig {
  resourceGroup: ScalingGroupNode!
  resourceSlots: JSONString!
  resourceOpts: JSONString
}

input ResourceConfigInput {
  resourceGroup: ResourceGroupInput!
  resourceSlots: JSONString!
  resourceOpts: JSONString = null
}

input ResourceGroupInput {
  name: String!
}

type RoutingNode implements Node {
  """The Globally Unique ID of this object"""
  id: ID!
  routingId: UUID!
  endpoint: String!
  session: UUID!
  status: String!
  trafficRatio: Float!
  createdAt: DateTime!
  liveStat: JSONString!
}

extend type ScalingGroupNode @key(fields: "id") {
  id: ID! @external
}

type ScalingRule {
  autoScalingRules: [EndpointAutoScalingRuleNode!]!
}

input ScanArtifactInput {
  registryId: ID!
  storageId: ID!
  limit: Int!
  search: String = null
}

type ScanArtifactsPayload {
  artifacts: [Artifact!]!
}

"""Different service configurations for model runtime"""
union ServiceConfig = RawServiceConfig

type SourceInfo {
  name: String
  url: String
}

input StringFilter {
  contains: String = null
  startsWith: String = null
  endsWith: String = null
  equals: String = null
  notEquals: String = null
  iContains: String = null
  iStartsWith: String = null
  iEndsWith: String = null
  iEquals: String = null
  iNotEquals: String = null
}

type Subscription {
  artifactStatusChanged(input: ArtifactStatusChangedInput!): ArtifactStatusChangedPayload!
  artifactImportProgressUpdated(artifactId: ID!): ArtifactImportProgressUpdatedPayload!
  deploymentStatusChanged(deploymentId: ID!): DeploymentStatusChangedPayload!
  replicaStatusChanged(revisionId: ID!): ReplicaStatusChangedPayload!
}

scalar UUID

input UnauthorizeArtifactInput {
  artifactId: ID!
}

type UnauthorizeArtifactPayload {
  artifact: Artifact!
}

input UpdateArtifactInput {
  artifactId: ID!
}

type UpdateArtifactPayload {
  artifact: Artifact!
}

input UpdateHuggingFaceRegistryInput {
  id: ID!
  url: String
  name: String
  token: String
}

type UpdateHuggingFaceRegistryPayload {
  huggingfaceRegistry: HuggingFaceRegistry!
}

input UpdateModelDeploymentInput {
  id: ID!
  openToPublic: Boolean = null
  tags: [String!] = null
  deploymentStrategy: DeploymentStrategyInput = null
  activeRevisionId: ID = null
}

type UpdateModelDeploymentPayload {
  deployment: ModelDeployment
}

input UpdateObjectStorageInput {
  id: ID!
  name: String
  host: String
  accessKey: String
  secretKey: String
  endpoint: String
  region: String
}

type UpdateObjectStoragePayload {
  objectStorage: ObjectStorage!
}

extend type UserNode @key(fields: "id") {
  id: ID! @external
}

extend type VirtualFolderNode @key(fields: "id") {
  id: ID! @external
}

scalar _Any

union _Entity = EndpointAutoScalingRuleNode | EndpointToken | ImageNode | ScalingGroupNode | UserNode | VirtualFolderNode

type _Service {
  sdl: String!
}