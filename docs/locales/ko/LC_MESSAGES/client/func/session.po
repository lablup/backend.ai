# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015-2022, Lablup Inc.
# This file is distributed under the same license as the Backend.AI
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI Documentation 22.06\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-11 22:50-0600\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../client/func/session.rst:2 d052193e64bd4d7e8eae8501f2df2556
msgid "ComputeSession Functions"
msgstr ""

#~ msgid "Provides various interactions with compute sessions in Backend.AI."
#~ msgstr ""

#~ msgid ""
#~ "The term 'kernel' is now deprecated "
#~ "and we prefer 'compute sessions'. "
#~ "However, for historical reasons and to"
#~ " avoid confusion with client sessions, "
#~ "we keep the backward compatibility with"
#~ " the naming of this API function "
#~ "class."
#~ msgstr ""

#~ msgid ""
#~ "For multi-container sessions, all "
#~ "methods take effects to the master "
#~ "container only, except "
#~ ":func:`~ComputeSession.destroy` and "
#~ ":func:`~ComputeSession.restart` methods. So it "
#~ "is the user's responsibility to "
#~ "distribute uploaded files to multiple "
#~ "containers using explicit copies or "
#~ "virtual folders which are commonly "
#~ "mounted to all containers belonging to"
#~ " the same compute session."
#~ msgstr ""

#~ msgid "Fetches the list of users. Domain admins can only get domain users."
#~ msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "Fetches active or inactive users only if not None."
#~ msgstr ""

#~ msgid "Additional per-user query fields to fetch."
#~ msgstr ""

#~ msgid "Return type"
#~ msgstr ""

#~ msgid ":py:class:`~ai.backend.client.output.types.PaginatedResult`\\[:py:class:`dict`]"
#~ msgstr ""

#~ msgid ""
#~ "Get-or-creates a compute session. "
#~ "If *name* is ``None``, it creates "
#~ "a new compute session as long as"
#~ " the server has enough resources and"
#~ " your API key has remaining quota."
#~ " If *name* is a valid string "
#~ "and there is an existing compute "
#~ "session with the same token and "
#~ "the same *image*, then it returns "
#~ "the :class:`ComputeSession` instance representing"
#~ " the existing session."
#~ msgstr ""

#~ msgid ""
#~ "The image name and tag for the "
#~ "compute session. Example: ``python:3.6-ubuntu``. "
#~ "Check out the full list of "
#~ "available images in your server using"
#~ " (TODO: new API)."
#~ msgstr ""

#~ msgid ""
#~ "A client-side (user-defined) identifier"
#~ " to distinguish the session among "
#~ "currently running sessions. It may be"
#~ " used to seamlessly reuse the session"
#~ " already created.  .. versionchanged:: "
#~ "19.12.0     Renamed from ``clientSessionToken``."
#~ msgstr ""

#~ msgid ""
#~ "A client-side (user-defined) identifier"
#~ " to distinguish the session among "
#~ "currently running sessions. It may be"
#~ " used to seamlessly reuse the session"
#~ " already created."
#~ msgstr ""

#~ msgid "Renamed from ``clientSessionToken``."
#~ msgstr ""

#~ msgid ""
#~ "Either ``\"interactive\"`` (default) or "
#~ "``\"batch\"``.  .. versionadded:: 19.09.0"
#~ msgstr ""

#~ msgid "Either ``\"interactive\"`` (default) or ``\"batch\"``."
#~ msgstr ""

#~ msgid ""
#~ "Just enqueue the session creation "
#~ "request and return immediately, without "
#~ "waiting for its startup. (default: "
#~ "``false`` to preserve the legacy "
#~ "behavior)  .. versionadded:: 19.09.0"
#~ msgstr ""

#~ msgid ""
#~ "Just enqueue the session creation "
#~ "request and return immediately, without "
#~ "waiting for its startup. (default: "
#~ "``false`` to preserve the legacy "
#~ "behavior)"
#~ msgstr ""

#~ msgid ""
#~ "The time to wait for session "
#~ "startup. If the cluster resource is "
#~ "being fully utilized, this waiting time"
#~ " can be arbitrarily long due to "
#~ "job queueing.  If the timeout reaches,"
#~ " the returned *status* field becomes "
#~ "``\"TIMEOUT\"``.  Still in this case, "
#~ "the session may start in the "
#~ "future.  .. versionadded:: 19.09.0"
#~ msgstr ""

#~ msgid ""
#~ "The time to wait for session "
#~ "startup. If the cluster resource is "
#~ "being fully utilized, this waiting time"
#~ " can be arbitrarily long due to "
#~ "job queueing.  If the timeout reaches,"
#~ " the returned *status* field becomes "
#~ "``\"TIMEOUT\"``.  Still in this case, "
#~ "the session may start in the "
#~ "future."
#~ msgstr ""

#~ msgid ""
#~ "Raises an explicit error if a "
#~ "session with the same *image* and "
#~ "the same *name* already exists instead"
#~ " of returning the information of it."
#~ "  .. versionadded:: 19.09.0"
#~ msgstr ""

#~ msgid ""
#~ "Raises an explicit error if a "
#~ "session with the same *image* and "
#~ "the same *name* already exists instead"
#~ " of returning the information of it."
#~ msgstr ""

#~ msgid "The list of vfolder names that belongs to the currrent API access key."
#~ msgstr ""

#~ msgid ""
#~ "Mapping which contains custom path to"
#~ " mount vfolder. Key and value of "
#~ "this map should be vfolder name "
#~ "and custom path. Defalut mounts or "
#~ "relative paths are under /home/work. If"
#~ " you want different paths, names "
#~ "should be absolute paths. The target "
#~ "mount path of vFolders should not "
#~ "overlap with the linux system folders."
#~ " vFolders which has a dot(.) prefix"
#~ " in its name are not affected."
#~ msgstr ""

#~ msgid "The environment variables which always bypasses the jail policy."
#~ msgstr ""

#~ msgid "The resource specification. (TODO: details)"
#~ msgstr ""

#~ msgid ""
#~ "The number of containers in this "
#~ "compute session. Must be at least "
#~ "1.  .. versionadded:: 19.09.0 .. "
#~ "versionchanged:: 20.09.0"
#~ msgstr ""

#~ msgid "The number of containers in this compute session. Must be at least 1."
#~ msgstr ""

#~ msgid ""
#~ "Set the clustering mode whether to "
#~ "use distributed nodes or a single "
#~ "node to spawn multiple containers for"
#~ " the new session.  .. versionadded:: "
#~ "20.09.0"
#~ msgstr ""

#~ msgid ""
#~ "Set the clustering mode whether to "
#~ "use distributed nodes or a single "
#~ "node to spawn multiple containers for"
#~ " the new session."
#~ msgstr ""

#~ msgid "An optional string to annotate extra information."
#~ msgstr ""

#~ msgid ""
#~ "An optional access key that owns "
#~ "the created session. (Only available to"
#~ " administrators)"
#~ msgstr ""

#~ msgid ":py:class:`~ai.backend.client.func.session.ComputeSession`"
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "The :class:`ComputeSession` instance."
#~ msgstr ""

#~ msgid ""
#~ "Get-or-creates a compute session "
#~ "from template. All other parameters "
#~ "provided  will be overwritten to "
#~ "template, including vfolder mounts (not "
#~ "appended!). If *name* is ``None``, it"
#~ " creates a new compute session as "
#~ "long as the server has enough "
#~ "resources and your API key has "
#~ "remaining quota. If *name* is a "
#~ "valid string and there is an "
#~ "existing compute session with the same"
#~ " token and the same *image*, then "
#~ "it returns the :class:`ComputeSession` "
#~ "instance representing the existing session."
#~ msgstr ""

#~ msgid "Task template to apply to compute session."
#~ msgstr ""

#~ msgid ""
#~ "Destroys the compute session. Since the"
#~ " server literally kills the container(s),"
#~ " all ongoing executions are forcibly "
#~ "interrupted."
#~ msgstr ""

#~ msgid ""
#~ "Restarts the compute session. The server"
#~ " force-destroys the current running "
#~ "container(s), but keeps their temporary "
#~ "scratch directories intact."
#~ msgstr ""

#~ msgid "Renames Session ID of running compute session."
#~ msgstr ""

#~ msgid "Commit a running session to a tar file in the agent host."
#~ msgstr ""

#~ msgid ""
#~ "Tries to interrupt the current ongoing"
#~ " code execution. This may fail "
#~ "without any explicit errors depending on"
#~ " the code being executed."
#~ msgstr ""

#~ msgid ""
#~ "Gets the auto-completion candidates from"
#~ " the given code string, as if a"
#~ " user has pressed the tab key "
#~ "just after the code in IDEs."
#~ msgstr ""

#~ msgid ""
#~ "Depending on the language of the "
#~ "compute session, this feature may not"
#~ " be supported.  Unsupported sessions "
#~ "returns an empty list."
#~ msgstr ""

#~ msgid "An (incomplete) code text."
#~ msgstr ""

#~ msgid ""
#~ "Additional information about the current "
#~ "cursor position, such as row, col, "
#~ "line and the remainder text."
#~ msgstr ""

#~ msgid ":py:class:`~typing.Iterable`\\[:py:class:`str`]"
#~ msgstr ""

#~ msgid "An ordered list of strings."
#~ msgstr ""

#~ msgid "Retrieves a brief information about the compute session."
#~ msgstr ""

#~ msgid "Retrieves the console log of the compute session container."
#~ msgstr ""

#~ msgid "Retrieves the status transition history of the compute session."
#~ msgstr ""

#~ msgid ""
#~ "Executes a code snippet directly in "
#~ "the compute session or sends a set"
#~ " of build/clean/execute commands to the "
#~ "compute session."
#~ msgstr ""

#~ msgid ""
#~ "For more details about using this "
#~ "API, please refer :doc:`the official API"
#~ " documentation <user-api/intro>`."
#~ msgstr ""

#~ msgid ""
#~ "A unique identifier for a particular "
#~ "run loop.  In the first call, it"
#~ " may be ``None`` so that the "
#~ "server auto-assigns one. Subsequent "
#~ "calls must use the returned ``runId``"
#~ " value to request continuation or to"
#~ " send user inputs."
#~ msgstr ""

#~ msgid ""
#~ "A code snippet as string.  In the"
#~ " continuation requests, it must be an"
#~ " empty string.  When sending user "
#~ "inputs, this is where the user "
#~ "input string is stored."
#~ msgstr ""

#~ msgid ""
#~ "A constant string which is one of"
#~ " ``\"query\"``, ``\"batch\"``, ``\"continue\"``, "
#~ "and ``\"user-input\"``."
#~ msgstr ""

#~ msgid ""
#~ "A dict for specifying additional "
#~ "options. Mainly used in the batch "
#~ "mode to specify build/clean/execution "
#~ "commands. See :ref:`the API object "
#~ "reference <batch-execution-query-object>` "
#~ "for details."
#~ msgstr ""

#~ msgid ":ref:`An execution result object <execution-result-object>`"
#~ msgstr ""

#~ msgid ""
#~ "Uploads the given list of files to"
#~ " the compute session. You may refer"
#~ " them in the batch-mode execution "
#~ "or from the code executed in the"
#~ " server afterwards."
#~ msgstr ""

#~ msgid ""
#~ "The list of file paths in the "
#~ "client-side. If the paths include "
#~ "directories, the location of them in "
#~ "the compute session is calculated from"
#~ " the relative path to *basedir* and"
#~ " all intermediate parent directories are"
#~ " automatically created if not exists.  "
#~ "For example, if a file path is "
#~ "``/home/user/test/data.txt`` (or ``test/data.txt``) "
#~ "where *basedir* is ``/home/user`` (or "
#~ "the current working directory is "
#~ "``/home/user``), the uploaded file is "
#~ "located at ``/home/work/test/data.txt`` in the"
#~ " compute session container."
#~ msgstr ""

#~ msgid ""
#~ "The list of file paths in the "
#~ "client-side. If the paths include "
#~ "directories, the location of them in "
#~ "the compute session is calculated from"
#~ " the relative path to *basedir* and"
#~ " all intermediate parent directories are"
#~ " automatically created if not exists."
#~ msgstr ""

#~ msgid ""
#~ "For example, if a file path is "
#~ "``/home/user/test/data.txt`` (or ``test/data.txt``) "
#~ "where *basedir* is ``/home/user`` (or "
#~ "the current working directory is "
#~ "``/home/user``), the uploaded file is "
#~ "located at ``/home/work/test/data.txt`` in the"
#~ " compute session container."
#~ msgstr ""

#~ msgid ""
#~ "The directory prefix where the files "
#~ "reside. The default value is the "
#~ "current working directory."
#~ msgstr ""

#~ msgid "Displays a progress bar during uploads."
#~ msgstr ""

#~ msgid "Downloads the given list of files from the compute session."
#~ msgstr ""

#~ msgid ""
#~ "The list of file paths in the "
#~ "compute session. If they are relative"
#~ " paths, the path is calculated from"
#~ " ``/home/work`` in the compute session "
#~ "container."
#~ msgstr ""

#~ msgid "The destination directory in the client-side."
#~ msgstr ""

#~ msgid "Displays a progress bar during downloads."
#~ msgstr ""

#~ msgid ""
#~ "Gets the list of files in the "
#~ "given path inside the compute session"
#~ " container."
#~ msgstr ""

#~ msgid "The directory path in the compute session."
#~ msgstr ""

#~ msgid ""
#~ "Opens the stream of the kernel "
#~ "lifecycle events. Only the master kernel"
#~ " of each session is monitored."
#~ msgstr ""

#~ msgid ":py:class:`~ai.backend.client.request.SSEContextManager`"
#~ msgstr ""

#~ msgid "a :class:`StreamEvents` object."
#~ msgstr ""

#~ msgid ""
#~ "Opens a pseudo-terminal of the "
#~ "kernel (if supported) streamed via "
#~ "websockets."
#~ msgstr ""

#~ msgid ":py:class:`~ai.backend.client.request.WebSocketContextManager`"
#~ msgstr ""

#~ msgid "a :class:`StreamPty` object."
#~ msgstr ""

#~ msgid ""
#~ "Executes a code snippet in the "
#~ "streaming mode. Since the returned "
#~ "websocket represents a run loop, there"
#~ " is no need to specify *run_id* "
#~ "explicitly."
#~ msgstr ""

#~ msgid ""
#~ "A derivative class of "
#~ ":class:`~ai.backend.client.request.WebSocketResponse` which "
#~ "provides additional functions to control "
#~ "the terminal."
#~ msgstr ""

