# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, Lablup Inc.
# This file is distributed under the same license as the Backend.AI API
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI API Documentation 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-08 23:35+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../user-api/events.rst:4
msgid "Event Monitoring"
msgstr "이벤트 모니터링"

#: ../../user-api/events.rst:7
msgid "Kernel Lifecycle Events"
msgstr "커널 라이프사이클 이벤트"

#: ../../user-api/events.rst:9
msgid "URI: ``/stream/kernel/_/events``"
msgstr "URI: ``/stream/kernel/_/events``"

#: ../../user-api/events.rst:10 ../../user-api/exec-batch.rst:139
#: ../../user-api/exec-batch.rst:198 ../../user-api/resource-presets.rst:19
#: ../../user-api/sessions.rst:199 ../../user-api/vfolders.rst:32
#: ../../user-api/vfolders.rst:80 ../../user-api/vfolders.rst:209
#: ../../user-api/vfolders.rst:308 ../../user-api/vfolders.rst:460
#: ../../user-api/vfolders.rst:516 ../../user-api/vfolders.rst:615
msgid "Method: ``GET``"
msgstr "메소드 : ``GET``"

#: ../../user-api/events.rst:12
msgid ""
"Provides a continuous message-by-message JSON object stream of kernel "
"lifecycles. It uses `HTML5 Server-Sent Events (SSE) "
"<https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events>`_. "
"Browser-based clients may use `the EventSource API "
"<https://developer.mozilla.org/en-US/docs/Web/API/EventSource>`_ for "
"convenience."
msgstr ""
"커널 라이프사이클의 메시지별 JSON 객체 스트림을 지속적으로 제공합니다."
"`HTML5 Server-Sent Events (SSE) <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events>`_"
"를 사용합니다. 브라우저 기반의 클라이언트는 편의상 "
"`the EventSource API <https://developer.mozilla.org/en-US/docs/Web/API/EventSource>`_ 를 "
"사용할 수 있습니다."

#: ../../user-api/events.rst:19
msgid ""
"First properly implemented in this version, deprecating prior "
"unimplemented interfaces."
msgstr ""
"이 버전에서 처음 적절하게 구현되었고 구현 되지 않았던 이전 "
"인터페이스는 폐지됩니다."


#: ../../user-api/events.rst:23 ../../user-api/exec-batch.rst:15
#: ../../user-api/exec-batch.rst:68 ../../user-api/exec-batch.rst:142
#: ../../user-api/exec-batch.rst:201 ../../user-api/exec-query.rst:17
#: ../../user-api/exec-query.rst:259 ../../user-api/exec-query.rst:349
#: ../../user-api/exec-stream.rst:49 ../../user-api/resource-presets.rst:22
#: ../../user-api/resource-presets.rst:62 ../../user-api/service-ports.rst:58
#: ../../user-api/service-ports.rst:91 ../../user-api/sessions.rst:17
#: ../../user-api/sessions.rst:206 ../../user-api/sessions.rst:266
#: ../../user-api/sessions.rst:316 ../../user-api/vfolders.rst:35
#: ../../user-api/vfolders.rst:83 ../../user-api/vfolders.rst:131
#: ../../user-api/vfolders.rst:216 ../../user-api/vfolders.rst:275
#: ../../user-api/vfolders.rst:311 ../../user-api/vfolders.rst:366
#: ../../user-api/vfolders.rst:416 ../../user-api/vfolders.rst:463
#: ../../user-api/vfolders.rst:519 ../../user-api/vfolders.rst:573
#: ../../user-api/vfolders.rst:618 ../../user-api/vfolders.rst:657
#: ../../user-api/vfolders.rst:713 ../../user-api/vfolders.rst:766
msgid "Parameters"
msgstr "매개변수들"

#: ../../user-api/events.rst:29 ../../user-api/exec-batch.rst:74
#: ../../user-api/exec-batch.rst:148 ../../user-api/exec-batch.rst:207
#: ../../user-api/exec-query.rst:23 ../../user-api/exec-query.rst:265
#: ../../user-api/exec-query.rst:355 ../../user-api/exec-stream.rst:55
#: ../../user-api/service-ports.rst:64 ../../user-api/service-ports.rst:97
#: ../../user-api/sessions.rst:23 ../../user-api/sessions.rst:212
#: ../../user-api/sessions.rst:272 ../../user-api/sessions.rst:322
#: ../../user-api/vfolders.rst:137 ../../user-api/vfolders.rst:222
#: ../../user-api/vfolders.rst:281 ../../user-api/vfolders.rst:317
#: ../../user-api/vfolders.rst:372 ../../user-api/vfolders.rst:422
#: ../../user-api/vfolders.rst:469 ../../user-api/vfolders.rst:525
#: ../../user-api/vfolders.rst:579 ../../user-api/vfolders.rst:663
#: ../../user-api/vfolders.rst:719 ../../user-api/vfolders.rst:772
msgid "Parameter"
msgstr "매개변수"

#: ../../user-api/events.rst:30 ../../user-api/exec-batch.rst:75
#: ../../user-api/exec-batch.rst:123 ../../user-api/exec-batch.rst:149
#: ../../user-api/exec-batch.rst:176 ../../user-api/exec-batch.rst:208
#: ../../user-api/exec-query.rst:24 ../../user-api/exec-query.rst:71
#: ../../user-api/exec-query.rst:266 ../../user-api/exec-query.rst:319
#: ../../user-api/exec-query.rst:356 ../../user-api/exec-stream.rst:56
#: ../../user-api/resource-presets.rst:43
#: ../../user-api/resource-presets.rst:85 ../../user-api/service-ports.rst:65
#: ../../user-api/service-ports.rst:98 ../../user-api/sessions.rst:24
#: ../../user-api/sessions.rst:147 ../../user-api/sessions.rst:213
#: ../../user-api/sessions.rst:238 ../../user-api/sessions.rst:273
#: ../../user-api/sessions.rst:298 ../../user-api/sessions.rst:323
#: ../../user-api/vfolders.rst:56 ../../user-api/vfolders.rst:104
#: ../../user-api/vfolders.rst:138 ../../user-api/vfolders.rst:181
#: ../../user-api/vfolders.rst:223 ../../user-api/vfolders.rst:249
#: ../../user-api/vfolders.rst:318 ../../user-api/vfolders.rst:346
#: ../../user-api/vfolders.rst:373 ../../user-api/vfolders.rst:423
#: ../../user-api/vfolders.rst:470 ../../user-api/vfolders.rst:498
#: ../../user-api/vfolders.rst:526 ../../user-api/vfolders.rst:554
#: ../../user-api/vfolders.rst:580 ../../user-api/vfolders.rst:639
#: ../../user-api/vfolders.rst:664 ../../user-api/vfolders.rst:697
#: ../../user-api/vfolders.rst:720 ../../user-api/vfolders.rst:751
#: ../../user-api/vfolders.rst:773 ../../user-api/vfolders.rst:798
msgid "Type"
msgstr "타입"

#: ../../user-api/events.rst:31 ../../user-api/events.rst:61
#: ../../user-api/events.rst:98 ../../user-api/exec-batch.rst:54
#: ../../user-api/exec-batch.rst:76 ../../user-api/exec-batch.rst:113
#: ../../user-api/exec-batch.rst:150 ../../user-api/exec-batch.rst:165
#: ../../user-api/exec-batch.rst:209 ../../user-api/exec-batch.rst:225
#: ../../user-api/exec-query.rst:25 ../../user-api/exec-query.rst:61
#: ../../user-api/exec-query.rst:267 ../../user-api/exec-query.rst:309
#: ../../user-api/exec-query.rst:357 ../../user-api/exec-query.rst:370
#: ../../user-api/exec-stream.rst:57 ../../user-api/resource-presets.rst:34
#: ../../user-api/resource-presets.rst:74 ../../user-api/service-ports.rst:66
#: ../../user-api/service-ports.rst:99 ../../user-api/sessions.rst:25
#: ../../user-api/sessions.rst:132 ../../user-api/sessions.rst:214
#: ../../user-api/sessions.rst:227 ../../user-api/sessions.rst:239
#: ../../user-api/sessions.rst:274 ../../user-api/sessions.rst:287
#: ../../user-api/sessions.rst:299 ../../user-api/sessions.rst:324
#: ../../user-api/sessions.rst:337 ../../user-api/vfolders.rst:47
#: ../../user-api/vfolders.rst:95 ../../user-api/vfolders.rst:139
#: ../../user-api/vfolders.rst:166 ../../user-api/vfolders.rst:224
#: ../../user-api/vfolders.rst:237 ../../user-api/vfolders.rst:282
#: ../../user-api/vfolders.rst:294 ../../user-api/vfolders.rst:319
#: ../../user-api/vfolders.rst:334 ../../user-api/vfolders.rst:374
#: ../../user-api/vfolders.rst:391 ../../user-api/vfolders.rst:424
#: ../../user-api/vfolders.rst:440 ../../user-api/vfolders.rst:471
#: ../../user-api/vfolders.rst:486 ../../user-api/vfolders.rst:527
#: ../../user-api/vfolders.rst:542 ../../user-api/vfolders.rst:581
#: ../../user-api/vfolders.rst:599 ../../user-api/vfolders.rst:630
#: ../../user-api/vfolders.rst:665 ../../user-api/vfolders.rst:684
#: ../../user-api/vfolders.rst:721 ../../user-api/vfolders.rst:737
#: ../../user-api/vfolders.rst:774 ../../user-api/vfolders.rst:787
msgid "Description"
msgstr "설명"

#: ../../user-api/events.rst:32 ../../user-api/events.rst:99
msgid "``sessionId``"
msgstr "``sessionId``"

#: ../../user-api/events.rst:33 ../../user-api/exec-batch.rst:78
#: ../../user-api/exec-batch.rst:152 ../../user-api/exec-batch.rst:211
#: ../../user-api/exec-query.rst:27 ../../user-api/exec-query.rst:269
#: ../../user-api/exec-query.rst:359 ../../user-api/exec-stream.rst:59
#: ../../user-api/exec-stream.rst:62 ../../user-api/service-ports.rst:68
#: ../../user-api/service-ports.rst:71 ../../user-api/service-ports.rst:101
#: ../../user-api/service-ports.rst:104 ../../user-api/sessions.rst:35
#: ../../user-api/sessions.rst:150 ../../user-api/sessions.rst:216
#: ../../user-api/sessions.rst:276 ../../user-api/sessions.rst:326
#: ../../user-api/vfolders.rst:184 ../../user-api/vfolders.rst:723
#: ../../user-api/vfolders.rst:776
msgid "``slug``"
msgstr "``slug``"

#: ../../user-api/events.rst:34
msgid ""
"The session ID to monitor the lifecycle events. If set ``\"*\"``, the API"
" will stream events from all kernels visible to the client depending on "
"the client's role and permissions."
msgstr ""
"라이프사이클 이벤트를 모니터링하기 위한 세션 ID 입니다. ``\"*``로 설정하면, "
"API는 클라이언트의 역할과 권한에 따라 클라이언트에 보여지는 모든 커널에서 "
"이벤트를 스트리밍합니다."

#: ../../user-api/events.rst:37 ../../user-api/events.rst:101
msgid "``ownerAccessKey``"
msgstr "``ownerAccessKey``"

#: ../../user-api/events.rst:38 ../../user-api/events.rst:43
#: ../../user-api/exec-batch.rst:84 ../../user-api/exec-batch.rst:87
#: ../../user-api/exec-batch.rst:155 ../../user-api/exec-batch.rst:179
#: ../../user-api/exec-batch.rst:182 ../../user-api/exec-batch.rst:185
#: ../../user-api/exec-query.rst:30 ../../user-api/exec-query.rst:33
#: ../../user-api/exec-query.rst:37 ../../user-api/exec-query.rst:272
#: ../../user-api/exec-query.rst:275 ../../user-api/exec-query.rst:278
#: ../../user-api/sessions.rst:28 ../../user-api/sessions.rst:73
#: ../../user-api/sessions.rst:79 ../../user-api/sessions.rst:92
#: ../../user-api/sessions.rst:154 ../../user-api/sessions.rst:241
#: ../../user-api/vfolders.rst:107 ../../user-api/vfolders.rst:142
#: ../../user-api/vfolders.rst:145 ../../user-api/vfolders.rst:187
#: ../../user-api/vfolders.rst:190 ../../user-api/vfolders.rst:226
#: ../../user-api/vfolders.rst:321 ../../user-api/vfolders.rst:324
#: ../../user-api/vfolders.rst:376 ../../user-api/vfolders.rst:426
#: ../../user-api/vfolders.rst:429 ../../user-api/vfolders.rst:473
#: ../../user-api/vfolders.rst:476 ../../user-api/vfolders.rst:529
#: ../../user-api/vfolders.rst:583 ../../user-api/vfolders.rst:667
#: ../../user-api/vfolders.rst:670 ../../user-api/vfolders.rst:754
#: ../../user-api/vfolders.rst:801
msgid "``str``"
msgstr "``str``"

#: ../../user-api/events.rst:39
msgid ""
"*(optional)* The access key of the owner of the specified session, since "
"different access keys (users) may share a same session ID for different "
"session instances. You can specify this only when the client is either a "
"domain admin or a superadmin."
msgstr ""
"*(선택사항)* 다른 액세스 키(사용자)가 다른 세션 인스턴스에 대해 동일한 세션 아이디를 "
"공유할 수 있기 때문에 지정된 세션 소유자의 접근 키 입니다. 도메인 소유자나 슈퍼관리자만이 "
"이를 지정할 수 있습니다."
#: ../../user-api/events.rst:42 ../../user-api/sessions.rst:72
msgid "``group``"
msgstr "``group``"

#: ../../user-api/events.rst:44
msgid ""
"The group name to filter the lifecycle events. If set ``\"*\"``, the API "
"will stream events from all kernels visible to the client depending on "
"the client's role and permissions."
msgstr ""
"라이프사이클 이벤트를 필터링할 그룹 이름입니다. ``\"*``로 설정하면, "
"API는 클라이언트의 역할과 권한에 따라 클라이언트에 보여지는 모든 커널에서 "
"이벤트를 스트리밍합니다."

#: ../../user-api/events.rst:49
msgid "Responses"
msgstr "응답"

#: ../../user-api/events.rst:51
msgid ""
"The response is a continuous stream of UTF-8 text lines following the "
"``text/event-stream`` format. Each event is composed of the event type "
"and data, where the data part is encoded as JSON."
msgstr ""
"응답은 ``text/event-stream`` 형식을 따르는 연속적인 여러 줄의 UTF-8 텍스트 스트림입니다. 각 이벤트는 이벤트 "
"타입과 데이터로 구성되어 있으며, 데이터는 JSON 으로 인코딩 됩니다. "

#: ../../user-api/events.rst:54
msgid "Possible event names (more events may be added in the future):"
msgstr "가능한 이벤트 명(추후 더 많은 이벤트가 추가될 수 있습니다)"

#: ../../user-api/events.rst:60
msgid "Event Name"
msgstr "이벤트 명"

#: ../../user-api/events.rst:62
#, fuzzy
msgid "``kernel_preparing``"
msgstr "커널-준비"

#: ../../user-api/events.rst:63
msgid ""
"The session is just scheduled from the job queue and got an agent "
"resource allocation."
msgstr "세션이 방금 작업 큐에 스케쥴링 되었고, 에이전트로부터 자원 할당을 받았습니다."

#: ../../user-api/events.rst:64
#, fuzzy
msgid "``kernel_pulling``"
msgstr "커널-가져오기"

#: ../../user-api/events.rst:65
msgid ""
"The session begins pulling the kernel image (usually from a Docker "
"registry) to the scheduled agent."
msgstr "세션이 (대개 도커 레지스트리로부터 온) 커널 이미지를 예약된 에이전트로 가져오기 시작합니다."

#: ../../user-api/events.rst:66
#, fuzzy
msgid "``kernel_creating``"
msgstr "커널-생성"

#: ../../user-api/events.rst:67
msgid ""
"The session is being created as containers (or other entities in "
"different agent backends)."
msgstr "세션이 컨테이너 (또는 다른 에이전트 백엔드의 다른 객체로) 생성되는 중입니다."

#: ../../user-api/events.rst:68
#, fuzzy
msgid "``kernel_started``"
msgstr "커널-시작됨"

#: ../../user-api/events.rst:69
msgid "The session becomes ready to execute codes."
msgstr "세션에서 코드를 실행할 준비를 마쳤습니다."

#: ../../user-api/events.rst:70
#, fuzzy
msgid "``kernel_terminated``"
msgstr "커널-종료"

#: ../../user-api/events.rst:71
msgid "The session has terminated."
msgstr "세션이 종료되었습니다."

#: ../../user-api/events.rst:73
msgid "When using the EventSource API, you should add event listeners as follows:"
msgstr "이벤트소스 API를 사용할 경우, 다음을 따르는 이벤트 리스너를 추가해주십시오 : "

#: ../../user-api/events.rst:86
msgid ""
"The EventSource API must be used with the session-based authentication "
"mode (when the endpoint is a console-server) which uses the browser "
"cookies. Otherwise, you need to manually implement the event stream "
"parser using the standard fetch API running against the manager server."
msgstr ""
"이벤트소스 API는 (콘솔-서버가 종단점 일 때) 반드시 브라우저 쿠키를 사용하는 세션-기반 인증 모드여야 합니다. 다른 방식으로는"
" 관리자 서버에 대해 실행되는 표준 fetch API를 사용해 이벤트 스트림 파서를 수동으로 구현해야 합니다."

#: ../../user-api/events.rst:91
msgid ""
"The event data contains a JSON string like this (more fields may be added"
" in the future):"
msgstr "이벤트 데이터는 다음과 같은 JSON 문자열로 구성됩니다 (추후 더 많은 필드가 추가될 수 있음) : "

#: ../../user-api/events.rst:97
msgid "Field Name"
msgstr "필드 명"

#: ../../user-api/events.rst:100
msgid "The source session ID."
msgstr "소스 세션 아이디"

#: ../../user-api/events.rst:102
msgid "The access key who owns the session."
msgstr "세션을 소유하고 있는 액세스 키"

#: ../../user-api/events.rst:103
msgid "``reason``"
msgstr "``reason``"

#: ../../user-api/events.rst:104
msgid ""
"A short string that describes why the event happened. This may be "
"``null`` or an empty string."
msgstr ""
"이 이벤트가 왜 발생했는지에 대한 짧은 문자열입니다. 이것은 "
"``null``이거나 빈 문자열일 수 있습니다."

#: ../../user-api/events.rst:106 ../../user-api/exec-batch.rst:125
#: ../../user-api/exec-query.rst:73 ../../user-api/exec-query.rst:321
msgid "``result``"
msgstr "``result``"

#: ../../user-api/events.rst:107
msgid ""
"Only present for ``kernel-terminated`` events. Only meaningful for batch-"
"type sessions. Either one of: ``\"UNDEFINED\"``, ``\"SUCCESS\"``, "
"``\"FAILURE\"``"
msgstr ""
"``kernel-terminated`` 이벤트만을 위해 존재합니다. 배치-타입 세션에만 유의미합니다."
"다음 중 하나:  ``\"UNDEFINED\"``, ``\"SUCCESS\"``, ``\"FAILURE\"``"

#: ../../user-api/exec-batch.rst:2
msgid "Code Execution (Batch Mode)"
msgstr "코드 실행 (배치 모드)"

#: ../../user-api/exec-batch.rst:4
msgid ""
"Some kernels provide the batch mode, which offers an explicit build step "
"required for multi-module programs or compiled programming languages. In "
"this mode, you first upload files in prior to execution."
msgstr ""
"일부 커널은 배치 모드를 제공하는데, 이것은 다중 모듈 프로그램이나 컴파일된 프로그래밍 언어에 필요한 "
"명시적인 빌드 단계를 제공합니다. 이 모드에서는 실행 전에 먼저 파일을 업로드합니다."

#: ../../user-api/exec-batch.rst:9
msgid "Uploading files"
msgstr "파일 업로드"

#: ../../user-api/exec-batch.rst:11
msgid "URI: ``/session/:id/upload``"
msgstr "URI: ``/session/:id/upload``"

#: ../../user-api/exec-batch.rst:12 ../../user-api/exec-batch.rst:65
#: ../../user-api/exec-query.rst:8 ../../user-api/exec-query.rst:256
#: ../../user-api/exec-query.rst:346 ../../user-api/resource-presets.rst:59
#: ../../user-api/sessions.rst:12 ../../user-api/vfolders.rst:126
#: ../../user-api/vfolders.rst:359 ../../user-api/vfolders.rst:409
#: ../../user-api/vfolders.rst:654 ../../user-api/vfolders.rst:710
msgid "Method: ``POST``"
msgstr "Method: ``POST``"

#: ../../user-api/exec-batch.rst:17
msgid ""
"Upload files to the session. You may upload multiple files at once using "
"multi-part form-data encoding in the request body (RFC 1867/2388). The "
"uploaded files are placed under ``/home/work`` directory (which is the "
"home directory for all kernels by default), and existing files are always"
" overwritten. If the filename has a directory part, non-existing "
"directories will be auto-created. The path may be either absolute or "
"relative, but only sub-directories under ``/home/work`` is allowed to be "
"created."
msgstr ""
"세션에 파일을 업로드 하십시오. 요청 본문 (RFC 1867/2388)에서 다중-파트 폼-데이터 인코딩을 사용하여 "
"한번에 다중 파일들을 업로드 할 수 있습니다. 업로드된 파일들은 ``/home/work`` 디렉터리"
"(기본적으로 모든 커널의 홈 디렉터리)하위에 위치하며, 기존 파일은 항상 덮어씁니다."
"파일명에 디렉터리 부분이 있다면, 존재하지 않는 디렉터리가 자동-생성됩니다. 경로는 절대적이거나 "
"상대적일 수 있지만, ``/home/work``하위에 하위-디렉터리들만 생성될 수 있습니다."

#: ../../user-api/exec-batch.rst:26
msgid ""
"This API is for uploading frequently-changing source files in prior to "
"batch-mode execution. All files uploaded via this API is deleted when the"
" kernel terminates. Use :doc:`virtual folders </user-api/vfolders>` to "
"store and access larger, persistent, static data and library files for "
"your codes."
msgstr ""
"이 API는 배치-모드 실행 전에 자주 변경되는 소스 파일을 업로드 하기 위한 것입니다."
"커널이 종료되면 이 API를 통해 업로드된 모든 파일이 삭제됩니다. 코드를 위해 "
":doc:`virtual folders </user-api/vfolders>`를 사용하여 더 크고, 영구적인, 정적 데이터 및 "
"라이브러리 파일을 저장하고 액세스하십시오."

#: ../../user-api/exec-batch.rst:33
msgid ""
"You cannot upload files to mounted virtual folders using this API "
"directly. However, you may copy/move the generated files to virtual "
"folders in your build script or the main program for later uses."
msgstr ""
"이 API를 사용해서 탑재된 가상 폴더에 직접적으로 파일을 업로드할 수 없습니다."
"그러나, 이 후 사용을 위해서 빌드 스크립트나 메인 프로그램 안의 가상폴더로 생성된 파일을 "
"복사/이동할 수 있다."

#: ../../user-api/exec-batch.rst:36
msgid "There are several limits on this API:"
msgstr "이 API에는 몇 가지 제한이 있습니다."

#: ../../user-api/exec-batch.rst:41
msgid "The maximum size of each file"
msgstr "각 파일의 최대 사이즈"

#: ../../user-api/exec-batch.rst:42
msgid "1 MiB"
msgstr "1 MiB"

#: ../../user-api/exec-batch.rst:43
msgid "The number of files per upload request"
msgstr "업로드 요청당 파일 수"

#: ../../user-api/exec-batch.rst:44
msgid "20"
msgstr "20"

#: ../../user-api/exec-batch.rst:47 ../../user-api/exec-batch.rst:106
#: ../../user-api/exec-batch.rst:159 ../../user-api/exec-batch.rst:219
#: ../../user-api/exec-query.rst:54 ../../user-api/exec-query.rst:302
#: ../../user-api/exec-query.rst:363 ../../user-api/resource-presets.rst:27
#: ../../user-api/resource-presets.rst:67 ../../user-api/sessions.rst:125
#: ../../user-api/sessions.rst:220 ../../user-api/sessions.rst:280
#: ../../user-api/sessions.rst:330 ../../user-api/vfolders.rst:40
#: ../../user-api/vfolders.rst:88 ../../user-api/vfolders.rst:159
#: ../../user-api/vfolders.rst:230 ../../user-api/vfolders.rst:287
#: ../../user-api/vfolders.rst:328 ../../user-api/vfolders.rst:385
#: ../../user-api/vfolders.rst:434 ../../user-api/vfolders.rst:480
#: ../../user-api/vfolders.rst:536 ../../user-api/vfolders.rst:593
#: ../../user-api/vfolders.rst:623 ../../user-api/vfolders.rst:677
#: ../../user-api/vfolders.rst:730 ../../user-api/vfolders.rst:780
msgid "Response"
msgstr "응답"

#: ../../user-api/exec-batch.rst:53 ../../user-api/exec-batch.rst:112
#: ../../user-api/exec-batch.rst:164 ../../user-api/exec-batch.rst:224
#: ../../user-api/exec-query.rst:60 ../../user-api/exec-query.rst:308
#: ../../user-api/exec-query.rst:369 ../../user-api/resource-presets.rst:33
#: ../../user-api/resource-presets.rst:73 ../../user-api/sessions.rst:131
#: ../../user-api/sessions.rst:226 ../../user-api/sessions.rst:286
#: ../../user-api/sessions.rst:336 ../../user-api/vfolders.rst:46
#: ../../user-api/vfolders.rst:94 ../../user-api/vfolders.rst:165
#: ../../user-api/vfolders.rst:236 ../../user-api/vfolders.rst:293
#: ../../user-api/vfolders.rst:333 ../../user-api/vfolders.rst:390
#: ../../user-api/vfolders.rst:439 ../../user-api/vfolders.rst:485
#: ../../user-api/vfolders.rst:541 ../../user-api/vfolders.rst:598
#: ../../user-api/vfolders.rst:629 ../../user-api/vfolders.rst:683
#: ../../user-api/vfolders.rst:736 ../../user-api/vfolders.rst:786
msgid "HTTP Status Code"
msgstr "HTTP Status Code"

#: ../../user-api/exec-batch.rst:55
msgid "204 OK"
msgstr "204 OK"

#: ../../user-api/exec-batch.rst:56 ../../user-api/exec-batch.rst:167
#: ../../user-api/exec-batch.rst:227 ../../user-api/vfolders.rst:49
#: ../../user-api/vfolders.rst:97 ../../user-api/vfolders.rst:336
#: ../../user-api/vfolders.rst:393 ../../user-api/vfolders.rst:442
#: ../../user-api/vfolders.rst:488 ../../user-api/vfolders.rst:544
#: ../../user-api/vfolders.rst:601 ../../user-api/vfolders.rst:632
#: ../../user-api/vfolders.rst:686 ../../user-api/vfolders.rst:739
#: ../../user-api/vfolders.rst:789
msgid "Success."
msgstr "성공."

#: ../../user-api/exec-batch.rst:57 ../../user-api/vfolders.rst:169
#: ../../user-api/vfolders.rst:394 ../../user-api/vfolders.rst:443
#: ../../user-api/vfolders.rst:602 ../../user-api/vfolders.rst:687
#: ../../user-api/vfolders.rst:740
msgid "400 Bad Request"
msgstr "400 Bad Request"

#: ../../user-api/exec-batch.rst:58
msgid ""
"Returned when one of the uploaded file exeeds the size limit or there are"
" too many files."
msgstr ""
"업로드된 파일 중 하나가 크기 제한을 초과하거나 파일이 너무 많을 때 반환됩니다."


#: ../../user-api/exec-batch.rst:62
msgid "Executing with Build Step"
msgstr "빌드 단계를 사용하여 실행한다."

#: ../../user-api/exec-batch.rst:64 ../../user-api/sessions.rst:198
#: ../../user-api/sessions.rst:260 ../../user-api/sessions.rst:308
msgid "URI: ``/session/:id``"
msgstr "URI: ``/session/:id``"

#: ../../user-api/exec-batch.rst:77 ../../user-api/exec-batch.rst:151
#: ../../user-api/exec-batch.rst:210 ../../user-api/exec-query.rst:26
#: ../../user-api/exec-query.rst:268 ../../user-api/exec-query.rst:358
#: ../../user-api/exec-stream.rst:58 ../../user-api/service-ports.rst:67
#: ../../user-api/service-ports.rst:100 ../../user-api/sessions.rst:215
#: ../../user-api/sessions.rst:275 ../../user-api/sessions.rst:325
msgid "``:id``"
msgstr "``:id``"

#: ../../user-api/exec-batch.rst:79 ../../user-api/exec-batch.rst:153
#: ../../user-api/exec-batch.rst:212 ../../user-api/sessions.rst:217
#: ../../user-api/sessions.rst:277 ../../user-api/sessions.rst:327
#, fuzzy
msgid "The session ID."
msgstr "세션 ID."

#: ../../user-api/exec-batch.rst:80 ../../user-api/exec-query.rst:29
msgid "``mode``"
msgstr "``mode``"

#: ../../user-api/exec-batch.rst:81
msgid "``enum[str]``"
msgstr "``enum[str]``"

#: ../../user-api/exec-batch.rst:82
msgid "A constant string ``\"batch\"``."
msgstr "상수 문자열 ``\"batch\"``."

#: ../../user-api/exec-batch.rst:83 ../../user-api/exec-query.rst:32
#: ../../user-api/exec-query.rst:271
msgid "``code``"
msgstr "``code``"

#: ../../user-api/exec-batch.rst:85
msgid "Must be an empty string ``\"\"``."
msgstr "반드시 빈 문자열 ``\"\"``이어야 합니다."

#: ../../user-api/exec-batch.rst:86 ../../user-api/exec-query.rst:36
msgid "``runId``"
msgstr "``runId``"

#: ../../user-api/exec-batch.rst:88 ../../user-api/exec-query.rst:38
msgid ""
"A string of client-side unique identifier for this particular run. For "
"more details about the concept of a run, see :ref:`code-execution-model`."
" If not given, the API server will assign a random one in the first "
"response and the client must use it for the same run afterwards."
msgstr ""
"특정 실행을 위한 클라이언트측 고유 식별자 문자열 입니다. 해당 실행 개념에 대한 "
"자세한 사항은 "ref"`code-execution-model`을 참조하십시오. 문자열이 주어지지 않는다면, API 서버가 "
"첫 번째 응답에 임의로 하나를 할당할 것이고 클라이언트는 이후 같은 실행에서 이를 사용해야만 합니다."

#: ../../user-api/exec-batch.rst:91
msgid "``options``"
msgstr "``options``"

#: ../../user-api/exec-batch.rst:92 ../../user-api/exec-batch.rst:126
#: ../../user-api/exec-query.rst:74 ../../user-api/sessions.rst:85
#: ../../user-api/sessions.rst:301 ../../user-api/vfolders.rst:252
msgid "``object``"
msgstr "``object``"

#: ../../user-api/exec-batch.rst:93
msgid ":ref:`batch-execution-query-object`."
msgstr ":ref:`batch-execution-query-object`."

#: ../../user-api/exec-batch.rst:95 ../../user-api/sessions.rst:96
#: ../../user-api/sessions.rst:180 ../../user-api/vfolders.rst:62
#: ../../user-api/vfolders.rst:113 ../../user-api/vfolders.rst:148
#: ../../user-api/vfolders.rst:194
msgid "Example:"
msgstr "예시:"

#: ../../user-api/exec-batch.rst:114 ../../user-api/exec-batch.rst:166
#: ../../user-api/exec-batch.rst:226 ../../user-api/exec-query.rst:62
#: ../../user-api/exec-query.rst:310 ../../user-api/resource-presets.rst:35
#: ../../user-api/resource-presets.rst:75 ../../user-api/sessions.rst:133
#: ../../user-api/sessions.rst:228 ../../user-api/vfolders.rst:48
#: ../../user-api/vfolders.rst:96 ../../user-api/vfolders.rst:238
#: ../../user-api/vfolders.rst:335 ../../user-api/vfolders.rst:487
#: ../../user-api/vfolders.rst:543 ../../user-api/vfolders.rst:600
#: ../../user-api/vfolders.rst:631 ../../user-api/vfolders.rst:685
#: ../../user-api/vfolders.rst:738 ../../user-api/vfolders.rst:788
msgid "200 OK"
msgstr "200 OK"

#: ../../user-api/exec-batch.rst:115 ../../user-api/exec-query.rst:63
#: ../../user-api/exec-query.rst:311
msgid ""
"The kernel has responded with the execution result. The response body "
"contains a JSON object as described below."
msgstr ""
"커널이 실행 결과로 응답했습니다. 응답 본문에는 아래에 설명된 것처럼 JSON 객체가 포함되어 있습니다."

#: ../../user-api/exec-batch.rst:122 ../../user-api/exec-batch.rst:175
#: ../../user-api/exec-query.rst:70 ../../user-api/exec-query.rst:318
#: ../../user-api/resource-presets.rst:42
#: ../../user-api/resource-presets.rst:84 ../../user-api/sessions.rst:146
#: ../../user-api/vfolders.rst:55 ../../user-api/vfolders.rst:103
#: ../../user-api/vfolders.rst:180 ../../user-api/vfolders.rst:248
#: ../../user-api/vfolders.rst:345 ../../user-api/vfolders.rst:497
#: ../../user-api/vfolders.rst:553 ../../user-api/vfolders.rst:638
#: ../../user-api/vfolders.rst:696 ../../user-api/vfolders.rst:750
#: ../../user-api/vfolders.rst:797
msgid "Fields"
msgstr "필드"

#: ../../user-api/exec-batch.rst:124 ../../user-api/exec-batch.rst:177
#: ../../user-api/exec-query.rst:72 ../../user-api/exec-query.rst:320
#: ../../user-api/resource-presets.rst:44
#: ../../user-api/resource-presets.rst:86 ../../user-api/sessions.rst:148
#: ../../user-api/vfolders.rst:57 ../../user-api/vfolders.rst:105
#: ../../user-api/vfolders.rst:182 ../../user-api/vfolders.rst:250
#: ../../user-api/vfolders.rst:347 ../../user-api/vfolders.rst:499
#: ../../user-api/vfolders.rst:555 ../../user-api/vfolders.rst:640
#: ../../user-api/vfolders.rst:698 ../../user-api/vfolders.rst:752
#: ../../user-api/vfolders.rst:799
msgid "Values"
msgstr "값"

#: ../../user-api/exec-batch.rst:127 ../../user-api/exec-query.rst:75
msgid ":ref:`execution-result-object`."
msgstr ":ref:`execution-result-object`."

#: ../../user-api/exec-batch.rst:131
msgid "Listing Files"
msgstr "나열된 파일"

#: ../../user-api/exec-batch.rst:133
msgid ""
"Once files are uploaded to the session or generated during the execution "
"of the code, there is a need to identify what files actually are in the "
"current session. In this case, use this API to get the list of files of "
"your compute session."
msgstr ""
"코드를 실행하는 동안 파일이 세션에 업로드되거나 생성되면 현재 세션에 실제로 어떤 파일이 있는지 "
"확인할 필요가 있다. 이 경우 이 API를 사용하여 컴퓨팅 세션의 파일의 목록을 가져오십시오." 

#: ../../user-api/exec-batch.rst:138
msgid "URI: ``/session/:id/files``"
msgstr "URI: ``/session/:id/files``"

#: ../../user-api/exec-batch.rst:154 ../../user-api/vfolders.rst:323
#: ../../user-api/vfolders.rst:428
msgid "``path``"
msgstr "``path``"

#: ../../user-api/exec-batch.rst:156
msgid "Path inside the session (default: ``/home/work``)."
msgstr "세션 내부 경로 (default: ``\home\work``)."

#: ../../user-api/exec-batch.rst:168 ../../user-api/sessions.rst:230
#: ../../user-api/sessions.rst:290 ../../user-api/sessions.rst:340
#: ../../user-api/vfolders.rst:240 ../../user-api/vfolders.rst:297
#: ../../user-api/vfolders.rst:337 ../../user-api/vfolders.rst:397
#: ../../user-api/vfolders.rst:445 ../../user-api/vfolders.rst:489
#: ../../user-api/vfolders.rst:545 ../../user-api/vfolders.rst:604
#: ../../user-api/vfolders.rst:689 ../../user-api/vfolders.rst:743
#: ../../user-api/vfolders.rst:790
msgid "404 Not Found"
msgstr "404 Not Found"

#: ../../user-api/exec-batch.rst:169
msgid "There is no such path."
msgstr "해당 경로가 존재하지 않습니다."

#: ../../user-api/exec-batch.rst:178 ../../user-api/exec-batch.rst:213
#: ../../user-api/vfolders.rst:348 ../../user-api/vfolders.rst:531
#: ../../user-api/vfolders.rst:585
msgid "``files``"
msgstr "``files``"

#: ../../user-api/exec-batch.rst:180
msgid "Stringified json containing list of files."
msgstr "파일 목록을 포함하는 문자열화된 json"

#: ../../user-api/exec-batch.rst:181
msgid "``folder_path``"
msgstr "``folder_path``"

#: ../../user-api/exec-batch.rst:183
msgid "Absolute path inside session."
msgstr "세션 내부의 절대 경로"

#: ../../user-api/exec-batch.rst:184
msgid "``errors``"
msgstr "``errors``"

#: ../../user-api/exec-batch.rst:186
msgid "Any errors occurred during scanning the specified path."
msgstr "지정된 경로를 스캔하는 동안 생성된 오류"

#: ../../user-api/exec-batch.rst:190
msgid "Downloading Files"
msgstr "다운로드한 파일"

#: ../../user-api/exec-batch.rst:192
msgid "Download files from your compute session."
msgstr "컴퓨팅 세션에서 파일을 다운로드 하십시오."

#: ../../user-api/exec-batch.rst:194
msgid ""
"The response contents are multiparts with tarfile binaries. Post-"
"processing, such as unpacking and save them, should be handled by the "
"client."
msgstr ""
"응답 내용은 tarfile binaries가 있는 멀티파트입니다. unpacking과 저장 같은 Post-processing은 "
"클라이언트가 다뤄야만 합니다.

#: ../../user-api/exec-batch.rst:197
msgid "URI: ``/session/:id/download``"
msgstr "URI: ``/session/:id/download``"

#: ../../user-api/exec-batch.rst:214 ../../user-api/exec-query.rst:322
#: ../../user-api/vfolders.rst:110 ../../user-api/vfolders.rst:532
#: ../../user-api/vfolders.rst:586
msgid "``list[str]``"
msgstr "``list[str]``"

#: ../../user-api/exec-batch.rst:215
msgid ""
"File paths inside the kernel container to download. (maximum 5 files at "
"once)"
msgstr "다운로드할 커널 컨테이너 내부 파일 경로 (한 번에 최대 5개의 파일)"

#: ../../user-api/exec-query.rst:2
msgid "Code Execution (Query Mode)"
msgstr "코드 실행 (쿼리 모드)"

#: ../../user-api/exec-query.rst:5
msgid "Executing Snippet"
msgstr "실행중인 스니펫"

#: ../../user-api/exec-query.rst:7
msgid "URI: ``/kernel/:id``"
msgstr "URI: ``/kernel/:id``"

#: ../../user-api/exec-query.rst:10
msgid ""
"Executes a snippet of user code using the specified session. Each "
"execution request to a same session may have side-effects to subsequent "
"executions. For instance, setting a global variable in a request and "
"reading the variable in another request is completely legal. It is the "
"job of the user (or the front-end) to guarantee the correct execution "
"order of multiple interdependent requests. When the session is terminated"
" or restarted, all such volatile states vanish."
msgstr ""
"지정된 세션을 사용해서 사용자 코드 스니펫을 실행합니다. 동일한 세션에 대한 각 실행 요청은 "
"후속 실행 시 부작용을 일으킬 수 있습니다. 예를 들어, 요청에서 전역 변수를 설정하고 "
"다른 요청에서 변수를 읽는 것은 완전히 합법적입니다. 복수의 상호 의존적 요청의 정확한 실행 순서를 "
"보장하는 것은 사용자(혹은 front-end)의 일입니다. 세션이 종료되거나 다시 시작되면, 모든 휘발적 상태는 사라집니다."

#: ../../user-api/exec-query.rst:28 ../../user-api/exec-query.rst:270
#: ../../user-api/exec-query.rst:360 ../../user-api/exec-stream.rst:60
#: ../../user-api/service-ports.rst:69 ../../user-api/service-ports.rst:102
msgid "The kernel ID."
msgstr "커널 ID"

#: ../../user-api/exec-query.rst:31
msgid "A constant string ``\"query\"``."
msgstr "상수 문자열 ``\"query\"``."

#: ../../user-api/exec-query.rst:34
msgid ""
"A string of user-written code. All non-ASCII data must be encoded in "
"UTF-8 or any format acceptable by the kernel."
msgstr ""
"사용자가 쓴 코드 문자열입니다. 모든 non-ASCII 데이터는 반드시 UTF-8이나 커널에서 "
"허용하는 다른 형식으로 인코딩되어야 합니다."

#: ../../user-api/exec-query.rst:42 ../../user-api/exec-query.rst:287
#: ../../user-api/exec-query.rst:331
msgid "**Example:**"
msgstr "**예시:**"

#: ../../user-api/exec-query.rst:79
msgid ""
"Even when the user code raises exceptions, such queries are treated as "
"successful execution. i.e., The failure of this API means that our API "
"subsystem had errors, not the user codes."
msgstr ""
"사용자 코드가 예외를 제기해도, 이러한 쿼리들은 성공적인 실행으로 취급됩니다. 즉, "
"이 API의 실패는 유저 코드가 아닌 우리의 API 하위 시스템에 오류가 있다는 것을 의미합니다."

#: ../../user-api/exec-query.rst:84
msgid ""
"If the user code tries to breach the system, causes crashs (e.g., "
"segmentation fault), or runs too long (timeout), the session is "
"automatically terminated. In such cases, you will get incomplete console "
"logs with ``\"finished\"`` status earlier than expected. Depending on "
"situation, the ``result.stderr`` may also contain specific error "
"information."
msgstr ""
"만일 유저 코드가 시스템을 위반하려고 하거나, 충돌(e.g., "세그멘테이션 결함")을 일으키거나, "
"너무 오래 실행(timeout)하면, 세션이 자동적으로 종료됩니다. 이러한 경우에, 예상보다 빠르게 "
"``\"finishted\"`` 상태로 불완전한 콘솔 로그를 얻게 됩니다. 상황에 따라 ``result.stderr``에도 구체적인 "
"에러 정보가 포함될 수 있습니다."

#: ../../user-api/exec-query.rst:89
msgid ""
"Here we demonstrate a few example returns when various Python codes are "
"executed."
msgstr ""
"우리는 다양한 Python 코드가 실행될 때 몇가지 예시 반환을 나타냅니다."

#: ../../user-api/exec-query.rst:91
msgid "**Example: Simple return.**"
msgstr "**예시: 간단한 반환.**"

#: ../../user-api/exec-query.rst:110
msgid "**Example: Runtime error.**"
msgstr "**예시: 런타임 에러.**"

#: ../../user-api/exec-query.rst:132
msgid "**Example: Multimedia output.**"
msgstr "**예시: 멀티미디어 결과**"

#: ../../user-api/exec-query.rst:134
msgid ""
"Media outputs are also mixed with other console outputs according to "
"their execution order."
msgstr ""
"미디어 출력물은 실행 순서에 따라 다른 콘솔 출력물과도 혼합됩니다."

#: ../../user-api/exec-query.rst:161
msgid "**Example: Continuation results.**"
msgstr "**예시: 지속적 결과**"

#: ../../user-api/exec-query.rst:184
msgid "Here you should make another API query with the empty ``code`` field."
msgstr "당신은 빈 ``code``필드로 다른 API 쿼리를 만들어야 합니다."

#: ../../user-api/exec-query.rst:199
msgid "Again."
msgstr "다시."

#: ../../user-api/exec-query.rst:214
msgid "**Example: User input.**"
msgstr "**예시: 사용자 입력**"

#: ../../user-api/exec-query.rst:237
msgid ""
"You should make another API query with the ``code`` field filled with the"
" user input."
msgstr "" 
"당신은 사용자 입력으로 채워진 ``code`` 필드로 다른 API 쿼리를 "
"만들어야 합니다."

#: ../../user-api/exec-query.rst:253
msgid "Auto-completion"
msgstr "자동-완성"

#: ../../user-api/exec-query.rst:255
msgid "URI: ``/kernel/:id/complete``"
msgstr "URI: ``/kernel/:id/complete``"

#: ../../user-api/exec-query.rst:273
msgid "A string containing the code until the current cursor position."
msgstr ""

#: ../../user-api/exec-query.rst:274
msgid "``options.post``"
msgstr ""

#: ../../user-api/exec-query.rst:276
msgid "A string containing the code after the current cursor position."
msgstr "현재 커서 위치까지 코드가 포함된 문자열."

#: ../../user-api/exec-query.rst:277
msgid "``options.line``"
msgstr "``options.line``"

#: ../../user-api/exec-query.rst:279
msgid "A string containing the content of the current line."
msgstr "현재 라인의 내용을 포함하는 문자열"

#: ../../user-api/exec-query.rst:280
msgid "``options.row``"
msgstr "``options.row``"

#: ../../user-api/exec-query.rst:281 ../../user-api/exec-query.rst:284
#: ../../user-api/sessions.rst:54 ../../user-api/sessions.rst:250
msgid "``int``"
msgstr "``int``"

#: ../../user-api/exec-query.rst:282
msgid "An integer indicating the line number (0-based) of the cursor."
msgstr "커서의 라인 번호(0-based)를 나타내는 정수"

#: ../../user-api/exec-query.rst:283
msgid "``options.col``"
msgstr "``options.col``"

#: ../../user-api/exec-query.rst:285
msgid ""
"An integer indicating the column number (0-based) in the current line of "
"the cursor."
msgstr "커서의 현재 라인에 있는 열 번호(0-based)를 나타내는 정수"

#: ../../user-api/exec-query.rst:324
msgid ""
"An ordered list containing the possible auto-completion matches as "
"strings. This may be empty if the current kernel does not implement auto-"
"completion or no matches have been found."
msgstr ""
"자동-완성 가능성을 포함하는 주문 리스트가 문자열로 일치합니다. 현재 커널이 자동-완성을 "
"시행하지 않거나 일치하는 항목이 발견되지 않을 경우 이는 비어있을 수 있습니다."

#: ../../user-api/exec-query.rst:328
msgid ""
"Selecting a match and merging it into the code text are up to the front-"
"end implementation."
msgstr ""
"일치를 선택하고 이를 코드 텍스트에 병합하는 것은 front-end 구현에 달려 있다."

#: ../../user-api/exec-query.rst:343
msgid "Interrupt"
msgstr "인터럽트"

#: ../../user-api/exec-query.rst:345
msgid "URI: ``/kernel/:id/interrupt``"
msgstr "URI: ``/kernel/:id/interrupt``"

#: ../../user-api/exec-query.rst:371 ../../user-api/sessions.rst:288
#: ../../user-api/sessions.rst:338 ../../user-api/vfolders.rst:295
msgid "204 No Content"
msgstr "204 내용 없음"

#: ../../user-api/exec-query.rst:372
msgid ""
"Sent the interrupt signal to the kernel. Note that this does *not* "
"guarantee the effectiveness of the interruption."
msgstr ""
"커널에 인터럽트 신호를 보냈습니다. 이것이 중단의 효과를 보장하지 *않는다는* 점에 유의하십시오."

#: ../../user-api/exec-stream.rst:4
msgid "Code Execution (Streaming)"
msgstr "코드 실행(스트리밍)"

#: ../../user-api/exec-stream.rst:6
msgid ""
"The streaming mode provides a lightweight and interactive method to "
"connect with the kernel containers."
msgstr ""
"스트리밍 모드는 커널 컨테이너와 연결할 수 있는 가볍고 상호호환적인 방법을 제공합니다."

#: ../../user-api/exec-stream.rst:10
msgid "Code Execution"
msgstr "코드 실행"

#: ../../user-api/exec-stream.rst:11
msgid "URI: ``/stream/kernel/:id/execute``"
msgstr "URI: ``/stream/kernel/:id/execute``"

#: ../../user-api/exec-stream.rst:12 ../../user-api/exec-stream.rst:28
#: ../../user-api/service-ports.rst:46 ../../user-api/service-ports.rst:79
msgid "Method: ``GET`` upgraded to WebSockets"
msgstr "Method: ``GET`` Websocket으로 업그레이드"

#: ../../user-api/exec-stream.rst:14
msgid ""
"This is a real-time streaming version of :doc:`exec-batch` and :doc"
":`exec-query` which uses long polling via HTTP."
msgstr ""
":HTTP를 통해 긴 폴링 방식을 사용하는 doc:`exec-batch`와 :doc:`exec-query`의 
"실시간 스트리밍 버전이다."

#: ../../user-api/exec-stream.rst:17
msgid "(under construction)"
msgstr "(구성 중)"

#: ../../user-api/exec-stream.rst:25
msgid "Terminal Emulation"
msgstr "터미널 에뮬레이션"

#: ../../user-api/exec-stream.rst:27
msgid "URI: ``/stream/kernel/:id/pty?app=:service``"
msgstr "URI: ``/stream/kernel/:id/pty?app=:service``"

#: ../../user-api/exec-stream.rst:30
msgid ""
"This endpoint provides a duplex continuous stream of JSON objects via the"
" native WebSocket. Although WebSocket supports binary streams, we "
"currently rely on TEXT messages only conveying JSON payloads to avoid "
"quirks in typed array support in Javascript across different browsers."
msgstr ""
"이 엔드포인트는 네이티브 웹소켓을 통해 Json 객체의 이중 연속 스트림을 제공한다."
"웹소켓은 바이너리 스트림을 지원하지만, 서로 다른 브라우저를 통한 Javascript의 "
"타이핑된 배열 지원에서 이상한 점을 방지하기 위해 현재는 JSON 페이로드만 "
"전달하는 TEXT 메시지에 의존하고 있다."

#: ../../user-api/exec-stream.rst:35 ../../user-api/service-ports.rst:51
#: ../../user-api/service-ports.rst:84
msgid ""
"The service name should be taken from the list of :ref:`service port "
"objects <service-port-object>` returned by :ref:`the session creation API"
" <create-session-api>`."
msgstr ""
"서비스 이름은 :ref:`the session creation API <create-session-api>`가 반환한 "
":ref:`service port objects <service-port-object>`의 리스트에서 가져와야 합니다."

#: ../../user-api/exec-stream.rst:41
msgid ""
"We do *not* provide any legacy WebSocket emulation interfaces such as "
"socket.io or SockJS. You need to set up your own proxy if you want to "
"support legacy browser users."
msgstr ""
"우리는 socket.io나 SockJS같은 기존 웹소켓 에뮬레이션 인터페이스를 제공하지 *않습니다.*"
"기존 브라우저 사용자를 지원하려면 자신의 프록시를 설정해야 합니다."

#: ../../user-api/exec-stream.rst:46
msgid "Added the ``service`` query parameter."
msgstr "``service`` 쿼리 매개변수를 추가하십시오."

#: ../../user-api/exec-stream.rst:61 ../../user-api/service-ports.rst:70
#: ../../user-api/service-ports.rst:103
msgid "``:service``"
msgstr "``:service``"

#: ../../user-api/exec-stream.rst:63 ../../user-api/service-ports.rst:72
#: ../../user-api/service-ports.rst:105
msgid "The service name to connect."
msgstr "연결할 서비스 명"

#: ../../user-api/exec-stream.rst:66
msgid "Client-to-Server Protocol"
msgstr "클라이언트-대-서버 프로토콜"

#: ../../user-api/exec-stream.rst:68
msgid "The endpoint accepts the following four types of input messages."
msgstr "엔드포인트에서 다음 네 가지 유형의 입력 메시지를 수락합니다."

#: ../../user-api/exec-stream.rst:71
msgid "Standard input stream"
msgstr "표준 입력 스트림"

#: ../../user-api/exec-stream.rst:73
msgid ""
"All ASCII (and UTF-8) inputs must be encoded as base64 strings. The "
"characters may include control characters as well."
msgstr ""
"모든 ASCII (및 UTF-8) 입력은 반드시 base64 문자열로 인코딩되어야 합니다."
"문자에는 제어 문자도 포함될 수 있습니다."

#: ../../user-api/exec-stream.rst:84
msgid "Terminal resize"
msgstr "터미널 크기 조정"

#: ../../user-api/exec-stream.rst:86
msgid ""
"Set the terminal size to the given number of rows and columns. You should"
" calculate them by yourself."
msgstr ""
"터미널 크기를 주어진 행과 열 수로 설정하십시오. "
"스스로 계산을 해야 합니다."

#: ../../user-api/exec-stream.rst:89
msgid ""
"For instance, for web-browsers, you may do a simple math by measuring the"
" width and height of a temporarily created, invisible HTML element with "
"the (monospace) font styles same to the terminal container element that "
"contains only a single ASCII character."
msgstr ""
"예를 들어, 웹브라우저의 경우, ASCII 문자 하나만 포함된 터미널 컨테이너 요소와 동일한 "
"(monospace) 글꼴 스타일을 이용해서, 임시로 생성된 보이지 않는 HTML 너비와 높이를 측정하여 "
"간단한 계산을 할 수 있다."


#: ../../user-api/exec-stream.rst:103
msgid "Ping"
msgstr "핑"

#: ../../user-api/exec-stream.rst:105
msgid ""
"Use this to keep the kernel alive (preventing it from auto-terminated by "
"idle timeouts) by sending pings periodically while the user-side browser "
"is open."
msgstr ""
"사용자측 브라우저가 열려있는 동안 주기적으로 ping을 전송하여 이 커널을 계속 유지하려면 "
(유휴 시간 초과에 의한 자동-종료 방지)이 기능을 사용하십시오. 

#: ../../user-api/exec-stream.rst:115
msgid "Restart"
msgstr "재시작"

#: ../../user-api/exec-stream.rst:117
msgid ""
"Use this to restart the kernel without affecting the working directory "
"and usage counts. Useful when your foreground terminal program does not "
"respond for whatever reasons."
msgstr ""
"작업 디렉토리 및 사용 수에 영향을 주지 않고 커널을 다시 시작하려면 이것을 사용하십시오. "
"어떤 이유로든 포그라운드 터미널이 응답하지 않을 때 유용합니다."

#: ../../user-api/exec-stream.rst:128
msgid "Server-to-Client Protocol"
msgstr "서버-대-고객 프로토콜"

#: ../../user-api/exec-stream.rst:131
msgid "Standard output/error stream"
msgstr "표준 결과/에러 스트림"

#: ../../user-api/exec-stream.rst:133
msgid ""
"Since the terminal is an output device, all stdout/stderr outputs are "
"merged into a single stream as we see in real terminals. This means there"
" is no way to distinguish stdout and stderr in the client-side, unless "
"your kernel applies some special formatting to distinguish them (e.g., "
"make all stderr otuputs red)."
msgstr ""
"터미널은 출력 장치이기 때문에 모든 stdout/stderr 출력은 실제 터미널에서 보는 것과 같이 "
"하나의 스트림으로 통합됩니다. 이것은 당신의 커널이 이들을 구별하기 위해 특별한 포맷을 "
"적용하지 않는 한(예시, 모든 stderr 출력을 빨갛게 해라) 클라이언트 측에서 stdout과 stderr을 "
"구별할 수 없다는 것을 의미합니다."


#: ../../user-api/exec-stream.rst:139
msgid ""
"The terminal output is compatible with xterm (including 256-color "
"support)."
msgstr ""

#: ../../user-api/exec-stream.rst:149
msgid "Server-side errors"
msgstr ""

#: ../../user-api/intro.rst:2
msgid "Introduction"
msgstr ""

#: ../../user-api/intro.rst:4
msgid ""
"Backend.AI User API is for running instant compute sessions at scale in "
"clouds or on-premise clusters."
msgstr ""

#: ../../user-api/intro.rst:10
msgid "Code Execution Model"
msgstr ""

#: ../../user-api/intro.rst:12
msgid ""
"The core of the user API is the **execute** call which allows clients to "
"execute user-provided codes in isolated **compute sessions** (aka "
"**kernels**). Each session is managed by a **kernel runtime**, whose "
"implementation is language-specific. A runtime is often a containerized "
"daemon that interacts with the Backend.AI agent via our internal ZeroMQ "
"protocol. In some cases, kernel runtimes may be just proxies to other "
"code execution services instead of actual executor daemons."
msgstr ""

#: ../../user-api/intro.rst:17
msgid ""
"Inside each compute session, a client may perform multiple **runs**. Each"
" run is for executing different code snippets (**the query mode**) or "
"different sets of source files (**the batch mode**). The client often has"
" to call the **execute** API *multiple times* to finish a single run. It "
"is completely legal to mix query-mode runs and batch-mode runs inside the"
" same session, given that the kernel runtime supports both modes."
msgstr ""

#: ../../user-api/intro.rst:22
msgid ""
"To distinguish different runs which may be overlapped, the client must "
"provide the same **run ID** to all **execute** calls during a single run."
" The run ID should be unique for each run and can be an arbitrary random "
"string. If the run ID is not provided by the client at the first execute "
"call of a run, the API server will assign a random one and inform it to "
"the client via the first response. Normally, if two or more runs are "
"overlapped, they are processed in a FIFO order using an internal queue. "
"But they may be processed in parallel if the kernel runtime supports "
"parallel processing. Note that the API server may raise a timeout error "
"and cancel the run if the waiting time exceeds a certain limit."
msgstr ""

#: ../../user-api/intro.rst:29
msgid ""
"In the query mode, usually the runtime context (e.g., global variables) "
"is preserved for next subsequent runs, but this is not guaranteed by the "
"API itself---it's up to the kernel runtime implementation."
msgstr ""

#: ../../user-api/intro.rst:34
msgid "The state diagram of a “run” with the **execute** API."
msgstr ""

#: ../../user-api/intro.rst:36
msgid ""
"The **execute** API accepts 4 arguments: ``mode``, ``runId``, ``code``, "
"and ``options`` (``opts``). It returns an :ref:`execution-result-object` "
"encoded as JSON."
msgstr ""

#: ../../user-api/intro.rst:39
msgid ""
"Depending on the value of ``status`` field in the returned :ref"
":`execution-result-object`, the client must perform another subsequent "
"**execute** call with appropriate arguments or stop. :numref:`run-state-"
"diagram` shows all possible states and transitions between them via the "
"``status`` field value."
msgstr ""

#: ../../user-api/intro.rst:43
msgid "If ``status`` is ``\"finished\"``, the client should stop."
msgstr ""

#: ../../user-api/intro.rst:45
msgid ""
"If ``status`` is ``\"continued\"``, the client should make another "
"**execute** API call with the ``code`` field set to an empty string and "
"the ``mode`` field set to ``\"continue\"``. Continuation happens when the"
" user code runs longer than a few seconds to allow the client to show its"
" progress, or when it requires extra step to finish the run cycle."
msgstr ""

#: ../../user-api/intro.rst:48
msgid ""
"If ``status`` is ``\"clean-finished\"`` or ``\"build-finished\"`` (this "
"happens at the batch-mode only), the client should make the same "
"continuation call. Since cleanup is performed before every build, the "
"client will always receive ``\"build-finished\"`` after ``\"clean-"
"finished\"`` status. All outputs prior to ``\"build-finished\"`` status "
"return are from the build program and all future outputs are from the "
"executed program built. Note that even when the ``exitCode`` value is "
"non-zero (failed), the client must continue to complete the run cycle."
msgstr ""

#: ../../user-api/intro.rst:53
msgid ""
"If ``status`` is ``\"waiting-input\"``, you should make another "
"**execute** API call with the ``code`` field set to the user-input text "
"and the ``mode`` field set to ``\"input\"``. This happens when the user "
"code calls interactive ``input()`` functions. Until you send the user "
"input, the current run is blocked. You may use modal dialogs or other "
"input forms (e.g., HTML input) to retrieve user inputs. When the server "
"receives the user input, the kernel's ``input()`` returns the given "
"value. Note that each kernel runtime may provide different ways to "
"trigger this interactive input cycle or may not provide at all."
msgstr ""

#: ../../user-api/intro.rst:60
msgid ""
"When each call returns, the ``console`` field in the :ref:`execution-"
"result-object` have the console logs captured since the last previous "
"call. Check out the following section for details."
msgstr ""

#: ../../user-api/intro.rst:67
msgid "Handling Console Output"
msgstr ""

#: ../../user-api/intro.rst:69
msgid ""
"The console output consists of a list of tuple pairs of item type and "
"item data. The item type is one of ``\"stdout\"``, ``\"stderr\"``, "
"``\"media\"``, ``\"html\"``, or ``\"log\"``."
msgstr ""

#: ../../user-api/intro.rst:72
msgid ""
"When the item type is ``\"stdout\"`` or ``\"stderr\"``, the item data is "
"the standard I/O stream outputs as (non-escaped) UTF-8 string. The total "
"length of either streams is limited to 524,288 Unicode characters per "
"each **execute** API call; all excessive outputs are truncated. The "
"stderr often includes language-specific tracebacks of (unhandled) "
"exceptions or errors occurred in the user code. If the user code "
"generates a mixture of stdout and stderr, the print ordering is preserved"
" and each contiguous block of stdout/stderr becomes a separate item in "
"the console output list so that the client user can reconstruct the same "
"console output by sequentially rendering the items."
msgstr ""

#: ../../user-api/intro.rst:79
msgid ""
"The text in the stdout/stderr item may contain arbitrary terminal control"
" sequences such as ANSI color codes and cursor/line manipulations. It is "
"the user's job to strip out them or implement some sort of terminal "
"emulation."
msgstr ""

#: ../../user-api/intro.rst:84
msgid ""
"Since the console texts are *not* escaped, the client user should take "
"care of rendering and escaping depending on the UI implementation. For "
"example, use ``<pre>`` element, replace newlines with ``<br>``, or apply "
"``white-space: pre`` CSS style when rendering as HTML. An easy way to do "
"escape the text safely is to use ``insertAdjacentText()`` DOM API."
msgstr ""

#: ../../user-api/intro.rst:88
msgid ""
"When the item type is ``\"media\"``, the item data is a pair of the MIME "
"type and the content data. If the MIME type is text-based (e.g., "
"``\"text/plain\"``) or XML-based (e.g., ``\"image/svg+xml\"``), the "
"content is just a string that represent the content. Otherwise, the data "
"is encoded as a data URI format (RFC 2397). You may use `backend.ai-media"
" library <https://github.com/lablup/backend.ai-media>`_ to handle this "
"field in Javascript on web-browsers."
msgstr ""

#: ../../user-api/intro.rst:93
msgid ""
"When the item type is ``\"html\"``, the item data is a partial HTML "
"document string, such as a table to show tabular data. If you are "
"implementing a web-based front-end, you may use it directly to the "
"standard DOM API, for instance, ``consoleElem.insertAdjacentHTML(value, "
"\"beforeend\")``."
msgstr ""

#: ../../user-api/intro.rst:96
msgid ""
"When the item type is ``\"log\"``, the item data is a 4-tuple of the log "
"level, the timestamp in the ISO 8601 format, the logger name and the log "
"message string. The log level may be one of ``\"debug\"``, ``\"info\"``, "
"``\"warning\"``, ``\"error\"``, or ``\"fatal\"``. You may use different "
"colors/formatting by the log level when printing the log message. Not "
"every kernel runtime supports this rich logging facility."
msgstr ""

#: ../../user-api/resource-presets.rst:2
msgid "Resource Presets"
msgstr ""

#: ../../user-api/resource-presets.rst:4
msgid ""
"Resource presets provide a simple storage for pre-configured resource "
"slots and a dynamic checker for allocatability of given presets before "
"actually calling the kernel creation API."
msgstr ""

#: ../../user-api/resource-presets.rst:8
msgid ""
"To add/modify/delete resource presets, you need to use the admin GraphQL "
"API."
msgstr ""

#: ../../user-api/resource-presets.rst:14
msgid "Listing Resource Presets"
msgstr ""

#: ../../user-api/resource-presets.rst:16
msgid "Returns the list of admin-configured resource presets."
msgstr ""

#: ../../user-api/resource-presets.rst:18
msgid "URI: ``/resource/presets``"
msgstr ""

#: ../../user-api/resource-presets.rst:24
#: ../../user-api/resource-presets.rst:64 ../../user-api/vfolders.rst:37
#: ../../user-api/vfolders.rst:85
msgid "None."
msgstr ""

#: ../../user-api/resource-presets.rst:36
#: ../../user-api/resource-presets.rst:76
msgid "The preset list is returned."
msgstr ""

#: ../../user-api/resource-presets.rst:45
#: ../../user-api/resource-presets.rst:103
msgid "``presets``"
msgstr ""

#: ../../user-api/resource-presets.rst:46
#: ../../user-api/resource-presets.rst:104 ../../user-api/sessions.rst:163
#: ../../user-api/vfolders.rst:59 ../../user-api/vfolders.rst:349
#: ../../user-api/vfolders.rst:642
msgid "``list[object]``"
msgstr ""

#: ../../user-api/resource-presets.rst:47
msgid "The list of :ref:`resource-preset-object`"
msgstr ""

#: ../../user-api/resource-presets.rst:51
msgid "Checking Allocatability of Resource Presets"
msgstr ""

#: ../../user-api/resource-presets.rst:53
msgid ""
"Returns current keypair and scaling-group's resource limits in addition "
"to the list of admin-configured resource presets. It also checks the "
"allocatability of the resource presets and adds ``allocatable`` boolean "
"field to each preset item."
msgstr ""

#: ../../user-api/resource-presets.rst:58
msgid "URI: ``/resource/check-presets``"
msgstr ""

#: ../../user-api/resource-presets.rst:77
msgid "401 Unauthorized"
msgstr ""

#: ../../user-api/resource-presets.rst:78
msgid "The client is not authorized."
msgstr ""

#: ../../user-api/resource-presets.rst:87
msgid "``keypair_limits``"
msgstr ""

#: ../../user-api/resource-presets.rst:88
#: ../../user-api/resource-presets.rst:92
#: ../../user-api/resource-presets.rst:95
#: ../../user-api/resource-presets.rst:99
msgid ":ref:`resource-slot-object`"
msgstr ""

#: ../../user-api/resource-presets.rst:89
msgid ""
"The maximum amount of total resource slots allowed for the current access"
" key. It may contain infinity values as the string \"Infinity\"."
msgstr ""

#: ../../user-api/resource-presets.rst:91
msgid "``keypair_using``"
msgstr ""

#: ../../user-api/resource-presets.rst:93
msgid "The amount of total resource slots used by the current access key."
msgstr ""

#: ../../user-api/resource-presets.rst:94
msgid "``keypair_remaining``"
msgstr ""

#: ../../user-api/resource-presets.rst:96
msgid ""
"The amount of total resource slots remaining for the current access key. "
"It may contain infinity values as the string \"Infinity\"."
msgstr ""

#: ../../user-api/resource-presets.rst:98
msgid "``scaling_group_remaining``"
msgstr ""

#: ../../user-api/resource-presets.rst:100
msgid ""
"The amount of total resource slots remaining for the current scaling "
"group. It may contain infinity values as the string \"Infinity\" if the "
"server is configured for auto-scaling."
msgstr ""

#: ../../user-api/resource-presets.rst:105
msgid ""
"The list of :ref:`resource-preset-object`, but with an extra boolean "
"field ``allocatable`` which indicates if the given resource slot is "
"actually allocatable considering the keypair's resrouce limits and the "
"scaling group's current usage."
msgstr ""

#: ../../user-api/service-ports.rst:2
msgid "Service Ports (aka Service Proxies)"
msgstr ""

#: ../../user-api/service-ports.rst:4
msgid ""
"The service ports API provides WebSocket-based authenticated and "
"encrypted tunnels to network-facing services (\"container services\") "
"provided by the kernel container. The main advantage of this feature is "
"that all application-specific network traffic are wrapped as a standard "
"WebSocket API (no need to open extra ports of the manager). It also hides"
" the container from the client and the client from the container, "
"offerring an extra level of security."
msgstr ""

#: ../../user-api/service-ports.rst:14
msgid "The diagram showing how tunneling of TCP connections via WebSockets works."
msgstr ""

#: ../../user-api/service-ports.rst:16
msgid ""
"As :numref:`service-port-diagram` shows, all TCP traffic to a container "
"service could be sent to a WebSocket connection to the following API "
"endpoints.  A single WebSocket connection corresponds to a single TCP "
"connection to the service, and there may be multiple concurrent WebSocket"
" connections to represent multiple TCP connections to the service.  It is"
" the client's responsibility to accept arbitrary TCP connections from "
"users (e.g., web browsers) with proper authorization for multi-user "
"setups and wrap those as WebSocket connections to the following APIs."
msgstr ""

#: ../../user-api/service-ports.rst:25
msgid ""
"When the first connection is initiated, the Backend.AI Agent running the "
"designated kernel container signals the kernel runner daemon in the "
"container to start the designated service.  It shortly waits for the in-"
"container port opening and then delivers the first packet to the service."
"  After initialization, all WebSocket payloads are delivered back and "
"forth just like normal TCP packets. Note that the WebSocket message type "
"must be ``BINARY``."
msgstr ""

#: ../../user-api/service-ports.rst:32
msgid ""
"The container service will see the packets from the manager and it never "
"knows the real origin of packets unless the service-level protocol "
"enforces to state such client-side information.  Likewise, the client "
"never knows the container's IP address (though the port numbers are "
"included in :ref:`service port objects <service-port-object>` returned by"
" :ref:`the session creation API <create-session-api>`)."
msgstr ""

#: ../../user-api/service-ports.rst:39
msgid "Currently non-TCP (e.g., UDP) services are not supported."
msgstr ""

#: ../../user-api/service-ports.rst:43
msgid "Service Proxy (HTTP)"
msgstr ""

#: ../../user-api/service-ports.rst:45
msgid "URI: ``/stream/kernel/:id/httpproxy?app=:service``"
msgstr ""

#: ../../user-api/service-ports.rst:48
msgid ""
"The service proxy API allows clients to directly connect to service "
"daemons running *inside* compute sessions, such as Jupyter and "
"TensorBoard."
msgstr ""

#: ../../user-api/service-ports.rst:76
msgid "Service Proxy (TCP)"
msgstr ""

#: ../../user-api/service-ports.rst:78
msgid "URI: ``/stream/kernel/:id/tcpproxy?app=:service``"
msgstr ""

#: ../../user-api/service-ports.rst:81
msgid ""
"This is the TCP version of service proxy, so that client users can "
"connect to native services running inside compute sessions, such as SSH."
msgstr ""

#: ../../user-api/sessions.rst:2
msgid "Session Management"
msgstr ""

#: ../../user-api/sessions.rst:4
msgid "Here are the API calls to create and manage compute sessions."
msgstr ""

#: ../../user-api/sessions.rst:9
msgid "Creating Session"
msgstr ""

#: ../../user-api/sessions.rst:11
msgid "URI: ``/session`` (``/session/create`` also works for legacy)"
msgstr ""

#: ../../user-api/sessions.rst:14
msgid ""
"Creates a new session or returns an existing session, depending on the "
"parameters."
msgstr ""

#: ../../user-api/sessions.rst:27
msgid "``image``"
msgstr ""

#: ../../user-api/sessions.rst:29
msgid ""
"The kernel runtime type in the form of the Docker image name and tag. For"
" legacy, the API also recognizes the ``lang`` field when ``image`` is not"
" present."
msgstr ""

#: ../../user-api/sessions.rst:34
msgid "``clientSessionToken``"
msgstr ""

#: ../../user-api/sessions.rst:36
msgid ""
"A client-provided session token, which must be unique among the currently"
" non-terminated sessions owned by the requesting access key. Clients may "
"reuse the token if the previous session with the same token has been "
"terminated."
msgstr ""

#: ../../user-api/sessions.rst:41
msgid ""
"It may contain ASCII alphabets, numbers, and hyphens in the middle. The "
"length must be between 4 to 64 characters inclusively. It is useful for "
"aliasing the session with a human-friendly name."
msgstr ""

#: ../../user-api/sessions.rst:45
msgid "``enqueueOnly``"
msgstr ""

#: ../../user-api/sessions.rst:46 ../../user-api/sessions.rst:62
#: ../../user-api/sessions.rst:176 ../../user-api/vfolders.rst:589
#: ../../user-api/vfolders.rst:726
msgid "``bool``"
msgstr ""

#: ../../user-api/sessions.rst:47
msgid ""
"*(optional)* If set true, the API returns immediately after queueing the "
"session creation request to the scheduler. Otherwise, the manager will "
"wait until the session gets started actually. (default: ``false``)"
msgstr ""

#: ../../user-api/sessions.rst:53
msgid "``maxWaitSeconds``"
msgstr ""

#: ../../user-api/sessions.rst:55
msgid ""
"*(optional)* Set the maximum duration to wait until the session starts "
"after queued, in seconds.  If zero, the manager will wait indefinitely. "
"(default: ``0``)"
msgstr ""

#: ../../user-api/sessions.rst:61
msgid "``reuseIfExists``"
msgstr ""

#: ../../user-api/sessions.rst:63
msgid ""
"*(optional)* If set true, the API returns *without* creating a new "
"session if a session with the same ID and the same image already exists "
"and not terminated. In this case ``config`` options are *ignored*. If set"
" false but a session with the same ID and image exists, the manager "
"returns an error: \"session already exists\". (default: ``true``)"
msgstr ""

#: ../../user-api/sessions.rst:74
msgid ""
"*(optional)* The name of a user group (aka \"project\") to launch the "
"session within.  (default: ``\"default\"``)"
msgstr ""

#: ../../user-api/sessions.rst:78
msgid "``domain``"
msgstr ""

#: ../../user-api/sessions.rst:80
msgid ""
"*(optional)* The name of a domain to launch the session within  (default:"
" ``\"default\"``)"
msgstr ""

#: ../../user-api/sessions.rst:84
msgid "``config``"
msgstr "``config``"

#: ../../user-api/sessions.rst:86
msgid ""
"*(optional)* A :ref:`creation-config-object` to specify kernel "
"configuration including resource requirements. If not given, the kernel "
"is created with the minimum required resource slots defined by the target"
" image."
msgstr ""

#: ../../user-api/sessions.rst:91
msgid "``tag``"
msgstr ""

#: ../../user-api/sessions.rst:93
msgid ""
"*(optional)* A per-session, user-provided tag for administrators to keep "
"track of additional information of each session, such as which sessions "
"are from which users."
msgstr ""

#: ../../user-api/sessions.rst:134
msgid "The session is already running and you are okay to reuse it."
msgstr ""

#: ../../user-api/sessions.rst:135 ../../user-api/vfolders.rst:167
#: ../../user-api/vfolders.rst:392 ../../user-api/vfolders.rst:441
msgid "201 Created"
msgstr ""

#: ../../user-api/sessions.rst:136
#, fuzzy
msgid "The session is successfully created."
msgstr "세션이 종료되었습니다."

#: ../../user-api/sessions.rst:137
msgid "401 Invalid API parameters"
msgstr ""

#: ../../user-api/sessions.rst:138
msgid "There are invalid or malformed values in the API parameters."
msgstr ""

#: ../../user-api/sessions.rst:139 ../../user-api/vfolders.rst:172
msgid "406 Not acceptable"
msgstr ""

#: ../../user-api/sessions.rst:140
msgid "The requested resource limits exceed the server's own limits."
msgstr ""

#: ../../user-api/sessions.rst:149
msgid "``sessId``"
msgstr ""

#: ../../user-api/sessions.rst:151
msgid ""
"The session ID used for later API calls, which is same to the value of "
"``clientSessionToken``. This will be random-generated by the server if "
"``clientSessionToken`` is not provided."
msgstr ""

#: ../../user-api/sessions.rst:153
msgid "``status``"
msgstr ""

#: ../../user-api/sessions.rst:155
msgid ""
"The status of the created kernel. This is always ``\"PENDING\"`` if "
"``enqueueOnly`` is set true. In other cases, it may be either "
"``\"RUNNING\"`` (normal case), ``\"ERROR\"``, or even ``\"TERMINATED\"`` "
"depending on what happens during session startup."
msgstr ""

#: ../../user-api/sessions.rst:162
msgid "``servicePorts``"
msgstr ""

#: ../../user-api/sessions.rst:164
msgid ""
"The list of :ref:`service-port-object`. This field becomes an empty list "
"if ``enqueueOnly`` is set true, because the final service ports are "
"determined when the session becomes ready after scheduling."
msgstr ""

#: ../../user-api/sessions.rst:170
msgid ""
"In most cases the service ports are same to what specified in the image "
"metadata, but the agent may add shared services for all sessions."
msgstr ""

#: ../../user-api/sessions.rst:175
msgid "``created``"
msgstr ""

#: ../../user-api/sessions.rst:177
#, fuzzy
msgid "True if the session is freshly created."
msgstr "세션이 종료되었습니다."

#: ../../user-api/sessions.rst:196
msgid "Getting Session Information"
msgstr ""

#: ../../user-api/sessions.rst:201
msgid ""
"Retrieves information about a session. For performance reasons, the "
"returned information may not be real-time; usually they are updated every"
" a few seconds in the server-side."
msgstr ""

#: ../../user-api/sessions.rst:229 ../../user-api/vfolders.rst:239
msgid "The information is successfully returned."
msgstr ""

#: ../../user-api/sessions.rst:231 ../../user-api/sessions.rst:291
#: ../../user-api/sessions.rst:341
#, fuzzy
msgid "There is no such session."
msgstr "소스 세션 아이디"

#: ../../user-api/sessions.rst:237 ../../user-api/sessions.rst:297
msgid "Key"
msgstr ""

#: ../../user-api/sessions.rst:240
msgid "``lang``"
msgstr ""

#: ../../user-api/sessions.rst:242
msgid "The kernel's programming language"
msgstr ""

#: ../../user-api/sessions.rst:243
msgid "``age``"
msgstr ""

#: ../../user-api/sessions.rst:244 ../../user-api/sessions.rst:253
msgid "``int`` (msec)"
msgstr ""

#: ../../user-api/sessions.rst:245
msgid "The time elapsed since the kernel has started."
msgstr ""

#: ../../user-api/sessions.rst:246
msgid "``memoryLimit``"
msgstr ""

#: ../../user-api/sessions.rst:247
msgid "``int`` (KiB)"
msgstr ""

#: ../../user-api/sessions.rst:248
msgid "The memory limit of the kernel in KiB."
msgstr ""

#: ../../user-api/sessions.rst:249
msgid "``numQueriesExecuted``"
msgstr ""

#: ../../user-api/sessions.rst:251
msgid "The number of times the kernel has been accessed."
msgstr ""

#: ../../user-api/sessions.rst:252
msgid "``cpuCreditUsed``"
msgstr ""

#: ../../user-api/sessions.rst:254
msgid "The total time the kernel was running."
msgstr ""

#: ../../user-api/sessions.rst:258
msgid "Destroying Session"
msgstr ""

#: ../../user-api/sessions.rst:261 ../../user-api/vfolders.rst:260
#: ../../user-api/vfolders.rst:570 ../../user-api/vfolders.rst:763
msgid "Method: ``DELETE``"
msgstr ""

#: ../../user-api/sessions.rst:263
msgid "Terminates a session."
msgstr ""

#: ../../user-api/sessions.rst:289
msgid "The session is successfully destroyed."
msgstr ""

#: ../../user-api/sessions.rst:300
msgid "``stats``"
msgstr ""

#: ../../user-api/sessions.rst:302
msgid "The :ref:`container-stats-object` of the kernel when deleted."
msgstr ""

#: ../../user-api/sessions.rst:306
msgid "Restarting Session"
msgstr ""

#: ../../user-api/sessions.rst:309
msgid "Method: ``PATCH``"
msgstr ""

#: ../../user-api/sessions.rst:311
msgid ""
"Restarts a session. The idle time of the session will be reset, but other"
" properties such as the age and CPU credit will continue to accumulate. "
"All global states such as global variables and modules imports are also "
"reset."
msgstr ""

#: ../../user-api/sessions.rst:339
msgid "The session is successfully restarted."
msgstr ""

#: ../../user-api/vfolders.rst:2
msgid "Virtual Folders"
msgstr ""

#: ../../user-api/vfolders.rst:4
msgid ""
"Virtual folders provide access to shared, persistent, and reused files "
"across different sessions."
msgstr ""

#: ../../user-api/vfolders.rst:7
msgid ""
"You can mount virtual folders when creating new sessions, and use them "
"like a plain directory on the local filesystem. Of course, reads/writes "
"to virtual folder contents may have degraded performance compared to the "
"main scratch directory (usually ``/home/work`` in most kernels) as "
"internally it uses a networked file system."
msgstr ""

#: ../../user-api/vfolders.rst:13
msgid ""
"Also, you might share your virtual folders with other users by inviting "
"them and granting them proper permission. Currently, there are three "
"levels of permissions: read-only, read-write, read-write-delete. They are"
" represented by short strings, ``'ro'``, ``'rw'``, ``'rd'``, "
"respectively. The owner of a virtual folder have read-write-delete "
"permission for the folder."
msgstr ""

#: ../../user-api/vfolders.rst:21
msgid ""
"Currently the total size of a virtual folder is limited to 1 GiB and the "
"number of files is limited to 1,000 files during public beta, but these "
"limits are subject to change in the future."
msgstr ""

#: ../../user-api/vfolders.rst:27
msgid "Listing Virtual Folders"
msgstr ""

#: ../../user-api/vfolders.rst:29
msgid "Returns the list of virtual folders created by the current keypair."
msgstr ""

#: ../../user-api/vfolders.rst:31 ../../user-api/vfolders.rst:125
msgid "URI: ``/folders``"
msgstr ""

#: ../../user-api/vfolders.rst:58 ../../user-api/vfolders.rst:251
msgid "(root)"
msgstr ""

#: ../../user-api/vfolders.rst:60
msgid "A list of :ref:`vfolder-list-item-object`."
msgstr ""

#: ../../user-api/vfolders.rst:73
msgid "Listing Virtual Folder Hosts"
msgstr ""

#: ../../user-api/vfolders.rst:75
msgid ""
"Returns the list of available host names where the current keypair can "
"create new virtual folders."
msgstr ""

#: ../../user-api/vfolders.rst:79
msgid "URI: ``/folders/_/hosts``"
msgstr ""

#: ../../user-api/vfolders.rst:106
msgid "``default``"
msgstr ""

#: ../../user-api/vfolders.rst:108
msgid "The default virtual folder host."
msgstr ""

#: ../../user-api/vfolders.rst:109
msgid "``allowed``"
msgstr ""

#: ../../user-api/vfolders.rst:111
msgid "The list of available virtual folder hosts."
msgstr ""

#: ../../user-api/vfolders.rst:123
msgid "Creating a Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:128
msgid "Creates a virtual folder associated with the current API key."
msgstr ""

#: ../../user-api/vfolders.rst:141 ../../user-api/vfolders.rst:186
#: ../../user-api/vfolders.rst:225 ../../user-api/vfolders.rst:283
msgid "``name``"
msgstr ""

#: ../../user-api/vfolders.rst:143 ../../user-api/vfolders.rst:227
#: ../../user-api/vfolders.rst:284 ../../user-api/vfolders.rst:322
#: ../../user-api/vfolders.rst:377 ../../user-api/vfolders.rst:427
#: ../../user-api/vfolders.rst:474 ../../user-api/vfolders.rst:530
#: ../../user-api/vfolders.rst:584 ../../user-api/vfolders.rst:668
msgid "The human-readable name of the virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:144 ../../user-api/vfolders.rst:189
msgid "``host``"
msgstr ""

#: ../../user-api/vfolders.rst:146
msgid "(optional) The name of the virtual folder host."
msgstr ""

#: ../../user-api/vfolders.rst:168
msgid "The kernel is successfully created."
msgstr ""

#: ../../user-api/vfolders.rst:170
msgid "The name is malformed or duplicate with your existing virtual folders."
msgstr ""

#: ../../user-api/vfolders.rst:173
msgid ""
"You have exceeded internal limits of virtual folders. (e.g., the maximum "
"number of folders you can have.)"
msgstr ""

#: ../../user-api/vfolders.rst:183
msgid "``id``"
msgstr ""

#: ../../user-api/vfolders.rst:185
msgid "The unique folder ID used for later API calls."
msgstr ""

#: ../../user-api/vfolders.rst:188
msgid "The human-readable name of the created virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:191
msgid "The name of the virtual folder host where the new folder is created."
msgstr ""

#: ../../user-api/vfolders.rst:206
msgid "Getting Virtual Folder Information"
msgstr ""

#: ../../user-api/vfolders.rst:208 ../../user-api/vfolders.rst:259
msgid "URI: ``/folders/:name``"
msgstr ""

#: ../../user-api/vfolders.rst:211
msgid ""
"Retrieves information about a virtual folder. For performance reasons, "
"the returned information may not be real-time; usually they are updated "
"every a few seconds in the server-side."
msgstr ""

#: ../../user-api/vfolders.rst:241
msgid ""
"There is no such folder or you may not have proper permission to access "
"the folder."
msgstr ""

#: ../../user-api/vfolders.rst:253
msgid ":ref:`vfolder-item-object`."
msgstr ""

#: ../../user-api/vfolders.rst:257
msgid "Deleting Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:262
msgid ""
"This immediately deletes all contents of the given virtual folder and "
"makes the folder unavailable for future mounts."
msgstr ""

#: ../../user-api/vfolders.rst:267
msgid ""
"If there are running kernels that have mounted the deleted virtual "
"folder, those kernels are likely to break!"
msgstr ""

#: ../../user-api/vfolders.rst:272
msgid "There is NO way to get back the contents once this API is invoked."
msgstr ""

#: ../../user-api/vfolders.rst:296
msgid "The folder is successfully destroyed."
msgstr ""

#: ../../user-api/vfolders.rst:298
msgid ""
"There is no such folder or you may not have proper permission to delete "
"the folder."
msgstr ""

#: ../../user-api/vfolders.rst:303
msgid "Listing Files in Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:305
msgid ""
"Returns the list of files in a virtual folder associated with current "
"keypair."
msgstr ""

#: ../../user-api/vfolders.rst:307
msgid "URI: ``/folders/:name/files``"
msgstr ""

#: ../../user-api/vfolders.rst:320 ../../user-api/vfolders.rst:375
#: ../../user-api/vfolders.rst:425 ../../user-api/vfolders.rst:472
#: ../../user-api/vfolders.rst:528 ../../user-api/vfolders.rst:582
#: ../../user-api/vfolders.rst:666
msgid "``:name``"
msgstr ""

#: ../../user-api/vfolders.rst:325
msgid "Path inside the virtual folder (default: root)."
msgstr ""

#: ../../user-api/vfolders.rst:338
msgid ""
"There is no such path or you may not have proper permission to access the"
" folder."
msgstr ""

#: ../../user-api/vfolders.rst:350
msgid "List of :ref:`vfolder-file-object`"
msgstr ""

#: ../../user-api/vfolders.rst:354
msgid "Uploading Multiple Files to Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:356
msgid "Upload local files to a virtual folder associated with current keypair."
msgstr ""

#: ../../user-api/vfolders.rst:358
msgid "URI: ``/folders/:name/upload``"
msgstr ""

#: ../../user-api/vfolders.rst:362
msgid ""
"If a file with the same name already exists in the virtual folder, it "
"will be overwritten without warning."
msgstr ""

#: ../../user-api/vfolders.rst:378 ../../user-api/vfolders.rst:500
#: ../../user-api/vfolders.rst:556
msgid "(body)"
msgstr ""

#: ../../user-api/vfolders.rst:379 ../../user-api/vfolders.rst:557
msgid "``multipart``"
msgstr ""

#: ../../user-api/vfolders.rst:380
msgid ""
"A multi-part encoded file data which is composed of multiple occurrences "
"of ``src`` field.  Each part must contain a valid filename and the "
"content type is always assumed as ``application/octet-stream``."
msgstr ""

#: ../../user-api/vfolders.rst:395
msgid ""
"There already exists a file with duplicated name that cannot be "
"overwritten in the virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:398 ../../user-api/vfolders.rst:446
msgid ""
"There is no such folder or you may not have proper permission to write "
"into folder."
msgstr ""

#: ../../user-api/vfolders.rst:403
msgid "Creating New Directory in Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:405
msgid ""
"Create a new directory in the virtual folder associated with current "
"keypair. this API recursively creates parent directories if they does not"
" exist."
msgstr ""

#: ../../user-api/vfolders.rst:408
msgid "URI: ``/folders/:name/mkdir``"
msgstr ""

#: ../../user-api/vfolders.rst:412
msgid ""
"If a directory with the same name already exists in the virtual folder, "
"it will be overwritten without warning."
msgstr ""

#: ../../user-api/vfolders.rst:430
msgid "The relative path of a new folder to create inside the virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:444
msgid "There already exists a file, not a directory, with duplicated name."
msgstr ""

#: ../../user-api/vfolders.rst:451
msgid "Downloading Single File from Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:453
msgid ""
"Download a single file from a virtual folder associated with the current "
"keypair. This API does not perform any encoding or compression but just "
"outputs the raw file content as the response body, for simpler client-"
"side implementation."
msgstr ""

#: ../../user-api/vfolders.rst:459
msgid "URI: ``/folders/:name/download_single``"
msgstr ""

#: ../../user-api/vfolders.rst:475
msgid "``file``"
msgstr ""

#: ../../user-api/vfolders.rst:477
msgid "A file path inside the virtual folder to download."
msgstr ""

#: ../../user-api/vfolders.rst:490 ../../user-api/vfolders.rst:546
msgid "File not found or you may not have proper permission to access the folder."
msgstr ""

#: ../../user-api/vfolders.rst:501
msgid "``bytes``"
msgstr ""

#: ../../user-api/vfolders.rst:502
msgid "The content of file."
msgstr ""

#: ../../user-api/vfolders.rst:505
msgid "Downloading Multiple Files from Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:507
msgid "Download files from a virtual folder associated with the current keypair."
msgstr ""

#: ../../user-api/vfolders.rst:509
msgid ""
"The response contents are streamed as gzipped binaries (``Content-"
"Encoding: gzip``) in a multi-part message format. Clients may detect the "
"total download size using ``X-TOTAL-PAYLOADS-LENGTH`` (all upper case) "
"HTTP header of the response in prior to reading/parsing the response "
"body."
msgstr ""

#: ../../user-api/vfolders.rst:515
msgid "URI: ``/folders/:name/download``"
msgstr ""

#: ../../user-api/vfolders.rst:533
msgid "File paths inside the virtual folder to download."
msgstr ""

#: ../../user-api/vfolders.rst:558
msgid "The gzipped content of files in the mixed multipart format."
msgstr ""

#: ../../user-api/vfolders.rst:562
msgid "Deleting Files in Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:564
msgid "This deletes files inside a virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:567
msgid "There is NO way to get back the files once this API is invoked."
msgstr ""

#: ../../user-api/vfolders.rst:569
msgid "URI: ``/folders/:name/delete_files``"
msgstr ""

#: ../../user-api/vfolders.rst:587
msgid "File paths inside the virtual folder to delete."
msgstr ""

#: ../../user-api/vfolders.rst:588
msgid "``recursive``"
msgstr ""

#: ../../user-api/vfolders.rst:590
msgid "Recursive option to delete folders if set to True. The default is False."
msgstr ""

#: ../../user-api/vfolders.rst:603
msgid "You tried to delete a folder without setting recursive option as True."
msgstr ""

#: ../../user-api/vfolders.rst:605
msgid ""
"There is no such folder or you may not have proper permission to delete "
"the file in the folder."
msgstr ""

#: ../../user-api/vfolders.rst:610
msgid "Listing Invitations for Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:612
msgid "Returns the list of pending invitations that requested user received."
msgstr ""

#: ../../user-api/vfolders.rst:614
msgid "URI: ``/folders/invitations/list``"
msgstr ""

#: ../../user-api/vfolders.rst:620
msgid "This API does not need any parameter."
msgstr ""

#: ../../user-api/vfolders.rst:641
msgid "``invitations``"
msgstr ""

#: ../../user-api/vfolders.rst:643
msgid "A list of :ref:`vfolder-invitation-object`."
msgstr ""

#: ../../user-api/vfolders.rst:647
msgid "Creating an Invitation"
msgstr ""

#: ../../user-api/vfolders.rst:649
msgid ""
"Invite other users to share a virtual folder with proper permissions. If "
"a user is already invited, then this API does not create a new invitation"
" or update the permission of the existing invitation."
msgstr ""

#: ../../user-api/vfolders.rst:653
msgid "URI: ``/folders/:name/invite``"
msgstr ""

#: ../../user-api/vfolders.rst:669
msgid "``perm``"
msgstr ""

#: ../../user-api/vfolders.rst:671
msgid "The permission to grant to invitee."
msgstr ""

#: ../../user-api/vfolders.rst:672
msgid "``user_ids``"
msgstr ""

#: ../../user-api/vfolders.rst:673 ../../user-api/vfolders.rst:700
msgid "``list[slug]``"
msgstr ""

#: ../../user-api/vfolders.rst:674
msgid "A list of user IDs to invite."
msgstr ""

#: ../../user-api/vfolders.rst:688
msgid "No invitee is given."
msgstr ""

#: ../../user-api/vfolders.rst:690
msgid "There is no invitation."
msgstr ""

#: ../../user-api/vfolders.rst:699
msgid "``invited_ids``"
msgstr ""

#: ../../user-api/vfolders.rst:701
msgid "A list of invited user IDs."
msgstr ""

#: ../../user-api/vfolders.rst:705
msgid "Accepting an Invitation"
msgstr ""

#: ../../user-api/vfolders.rst:707
msgid ""
"Accept an invitation and receive permission to a virtual folder as in the"
" invitation."
msgstr ""

#: ../../user-api/vfolders.rst:709
msgid "URI: ``/folders/invitations/accept``"
msgstr ""

#: ../../user-api/vfolders.rst:722 ../../user-api/vfolders.rst:775
msgid "``inv_id``"
msgstr ""

#: ../../user-api/vfolders.rst:724 ../../user-api/vfolders.rst:777
msgid "The unique invitation ID."
msgstr ""

#: ../../user-api/vfolders.rst:725
msgid "``inv_ak``"
msgstr ""

#: ../../user-api/vfolders.rst:727
msgid "The access key of invitee."
msgstr ""

#: ../../user-api/vfolders.rst:741
msgid ""
"The name of the target virtual folder is duplicate with your existing "
"virtual folders."
msgstr ""

#: ../../user-api/vfolders.rst:744 ../../user-api/vfolders.rst:791
msgid "There is no such invitation."
msgstr ""

#: ../../user-api/vfolders.rst:753 ../../user-api/vfolders.rst:800
msgid "``msg``"
msgstr ""

#: ../../user-api/vfolders.rst:755
msgid "Detail message for the invitation acceptance."
msgstr ""

#: ../../user-api/vfolders.rst:758
msgid "Rejecting an Invitation"
msgstr ""

#: ../../user-api/vfolders.rst:760
msgid "Reject an invitation."
msgstr ""

#: ../../user-api/vfolders.rst:762
msgid "URI: ``/folders/invitations/delete``"
msgstr ""

#: ../../user-api/vfolders.rst:802
msgid "Detail message for the invitation deletion."
msgstr ""

#~ msgid "URI: ``/kernel/:id/upload``"
#~ msgstr ""

#~ msgid "URI: ``/kernel/:id/files``"
#~ msgstr ""

#~ msgid "URI: ``/kernel/:id/download``"
#~ msgstr ""

#~ msgid ""
#~ "Executes a snippet of user code "
#~ "using the specified session. Each "
#~ "execution request to a same session "
#~ "may have side-effects to subsequent "
#~ "executions. For instance, setting a "
#~ "global variable in a request and "
#~ "reading the variable in another request"
#~ " is completely legal. It is the "
#~ "job of the user (or the front-"
#~ "end) to gaurantee the correct execution"
#~ " order of multiple interdependent requests."
#~ " When the kernel session is "
#~ "terminated or restarted, all such "
#~ "volatile states vanish."
#~ msgstr ""

#~ msgid "Kernel Management"
#~ msgstr ""

#~ msgid "URI: ``/kernel`` (``/kernel/create`` also works for legacy)"
#~ msgstr ""

#~ msgid ""
#~ "*(optional)* If set true, the API "
#~ "returns *without* creating a new session"
#~ " if a session with the same ID"
#~ " and the same image already exists"
#~ " and not terminated. In this case "
#~ "``config`` options are *ignored*. If set"
#~ " false but a session with the "
#~ "same ID and image exists, the "
#~ "manager returns an error: \"kernel "
#~ "already exists\". (default: ``true``)"
#~ msgstr ""

#~ msgid "The kernel is already running and you are okay to reuse it."
#~ msgstr ""

#~ msgid "``kernelId``"
#~ msgstr ""

#~ msgid ""
#~ "In most cases the service ports "
#~ "are same to what specified in the"
#~ " image metadata, but the agent may"
#~ " add shared services for all kernels."
#~ msgstr ""

#~ msgid "True if the kernel is freshly created."
#~ msgstr ""

#~ msgid "Getting Kernel Information"
#~ msgstr ""

#~ msgid "There is no such kernel."
#~ msgstr ""

#~ msgid "The kernel is successfully destroyed."
#~ msgstr ""

#~ msgid ""
#~ "Restarts a session. The idle time "
#~ "of the kernel will be reset, but"
#~ " other properties such as the age "
#~ "and CPU credit will continue to "
#~ "accumulate. All global states such as"
#~ " global variables and modules imports "
#~ "are also reset."
#~ msgstr ""

#~ msgid "The kernel is successfully restarted."
#~ msgstr ""

