# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, Lablup Inc.
# This file is distributed under the same license as the Backend.AI API
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI API Documentation 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-09-08 23:35+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../user-api/events.rst:4
msgid "Event Monitoring"
msgstr "이벤트 모니터링"

#: ../../user-api/events.rst:7
msgid "Kernel Lifecycle Events"
msgstr "커널 라이프사이클 이벤트"

#: ../../user-api/events.rst:9
msgid "URI: ``/stream/kernel/_/events``"
msgstr "URI: ``/stream/kernel/_/events``"

#: ../../user-api/events.rst:10 ../../user-api/exec-batch.rst:139
#: ../../user-api/exec-batch.rst:198 ../../user-api/resource-presets.rst:19
#: ../../user-api/sessions.rst:199 ../../user-api/vfolders.rst:32
#: ../../user-api/vfolders.rst:80 ../../user-api/vfolders.rst:209
#: ../../user-api/vfolders.rst:308 ../../user-api/vfolders.rst:460
#: ../../user-api/vfolders.rst:516 ../../user-api/vfolders.rst:615
msgid "Method: ``GET``"
msgstr "메소드 : ``GET``"

#: ../../user-api/events.rst:12
msgid ""
"Provides a continuous message-by-message JSON object stream of kernel "
"lifecycles. It uses `HTML5 Server-Sent Events (SSE) "
"<https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events>`_. "
"Browser-based clients may use `the EventSource API "
"<https://developer.mozilla.org/en-US/docs/Web/API/EventSource>`_ for "
"convenience."
msgstr ""
"커널 라이프사이클의 메시지별 JSON 객체 스트림을 지속적으로 제공합니다."
"`HTML5 Server-Sent Events (SSE) <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events>`_"
"를 사용합니다. 브라우저 기반의 클라이언트는 편의상 "
"`the EventSource API <https://developer.mozilla.org/en-US/docs/Web/API/EventSource>`_ 를 "
"사용할 수 있습니다."

#: ../../user-api/events.rst:19
msgid ""
"First properly implemented in this version, deprecating prior "
"unimplemented interfaces."
msgstr ""
"이 버전에서 처음 적절하게 구현되었고 구현 되지 않았던 이전 "
"인터페이스는 폐지됩니다."


#: ../../user-api/events.rst:23 ../../user-api/exec-batch.rst:15
#: ../../user-api/exec-batch.rst:68 ../../user-api/exec-batch.rst:142
#: ../../user-api/exec-batch.rst:201 ../../user-api/exec-query.rst:17
#: ../../user-api/exec-query.rst:259 ../../user-api/exec-query.rst:349
#: ../../user-api/exec-stream.rst:49 ../../user-api/resource-presets.rst:22
#: ../../user-api/resource-presets.rst:62 ../../user-api/service-ports.rst:58
#: ../../user-api/service-ports.rst:91 ../../user-api/sessions.rst:17
#: ../../user-api/sessions.rst:206 ../../user-api/sessions.rst:266
#: ../../user-api/sessions.rst:316 ../../user-api/vfolders.rst:35
#: ../../user-api/vfolders.rst:83 ../../user-api/vfolders.rst:131
#: ../../user-api/vfolders.rst:216 ../../user-api/vfolders.rst:275
#: ../../user-api/vfolders.rst:311 ../../user-api/vfolders.rst:366
#: ../../user-api/vfolders.rst:416 ../../user-api/vfolders.rst:463
#: ../../user-api/vfolders.rst:519 ../../user-api/vfolders.rst:573
#: ../../user-api/vfolders.rst:618 ../../user-api/vfolders.rst:657
#: ../../user-api/vfolders.rst:713 ../../user-api/vfolders.rst:766
msgid "Parameters"
msgstr "매개변수들"

#: ../../user-api/events.rst:29 ../../user-api/exec-batch.rst:74
#: ../../user-api/exec-batch.rst:148 ../../user-api/exec-batch.rst:207
#: ../../user-api/exec-query.rst:23 ../../user-api/exec-query.rst:265
#: ../../user-api/exec-query.rst:355 ../../user-api/exec-stream.rst:55
#: ../../user-api/service-ports.rst:64 ../../user-api/service-ports.rst:97
#: ../../user-api/sessions.rst:23 ../../user-api/sessions.rst:212
#: ../../user-api/sessions.rst:272 ../../user-api/sessions.rst:322
#: ../../user-api/vfolders.rst:137 ../../user-api/vfolders.rst:222
#: ../../user-api/vfolders.rst:281 ../../user-api/vfolders.rst:317
#: ../../user-api/vfolders.rst:372 ../../user-api/vfolders.rst:422
#: ../../user-api/vfolders.rst:469 ../../user-api/vfolders.rst:525
#: ../../user-api/vfolders.rst:579 ../../user-api/vfolders.rst:663
#: ../../user-api/vfolders.rst:719 ../../user-api/vfolders.rst:772
msgid "Parameter"
msgstr "매개변수"

#: ../../user-api/events.rst:30 ../../user-api/exec-batch.rst:75
#: ../../user-api/exec-batch.rst:123 ../../user-api/exec-batch.rst:149
#: ../../user-api/exec-batch.rst:176 ../../user-api/exec-batch.rst:208
#: ../../user-api/exec-query.rst:24 ../../user-api/exec-query.rst:71
#: ../../user-api/exec-query.rst:266 ../../user-api/exec-query.rst:319
#: ../../user-api/exec-query.rst:356 ../../user-api/exec-stream.rst:56
#: ../../user-api/resource-presets.rst:43
#: ../../user-api/resource-presets.rst:85 ../../user-api/service-ports.rst:65
#: ../../user-api/service-ports.rst:98 ../../user-api/sessions.rst:24
#: ../../user-api/sessions.rst:147 ../../user-api/sessions.rst:213
#: ../../user-api/sessions.rst:238 ../../user-api/sessions.rst:273
#: ../../user-api/sessions.rst:298 ../../user-api/sessions.rst:323
#: ../../user-api/vfolders.rst:56 ../../user-api/vfolders.rst:104
#: ../../user-api/vfolders.rst:138 ../../user-api/vfolders.rst:181
#: ../../user-api/vfolders.rst:223 ../../user-api/vfolders.rst:249
#: ../../user-api/vfolders.rst:318 ../../user-api/vfolders.rst:346
#: ../../user-api/vfolders.rst:373 ../../user-api/vfolders.rst:423
#: ../../user-api/vfolders.rst:470 ../../user-api/vfolders.rst:498
#: ../../user-api/vfolders.rst:526 ../../user-api/vfolders.rst:554
#: ../../user-api/vfolders.rst:580 ../../user-api/vfolders.rst:639
#: ../../user-api/vfolders.rst:664 ../../user-api/vfolders.rst:697
#: ../../user-api/vfolders.rst:720 ../../user-api/vfolders.rst:751
#: ../../user-api/vfolders.rst:773 ../../user-api/vfolders.rst:798
msgid "Type"
msgstr "타입"

#: ../../user-api/events.rst:31 ../../user-api/events.rst:61
#: ../../user-api/events.rst:98 ../../user-api/exec-batch.rst:54
#: ../../user-api/exec-batch.rst:76 ../../user-api/exec-batch.rst:113
#: ../../user-api/exec-batch.rst:150 ../../user-api/exec-batch.rst:165
#: ../../user-api/exec-batch.rst:209 ../../user-api/exec-batch.rst:225
#: ../../user-api/exec-query.rst:25 ../../user-api/exec-query.rst:61
#: ../../user-api/exec-query.rst:267 ../../user-api/exec-query.rst:309
#: ../../user-api/exec-query.rst:357 ../../user-api/exec-query.rst:370
#: ../../user-api/exec-stream.rst:57 ../../user-api/resource-presets.rst:34
#: ../../user-api/resource-presets.rst:74 ../../user-api/service-ports.rst:66
#: ../../user-api/service-ports.rst:99 ../../user-api/sessions.rst:25
#: ../../user-api/sessions.rst:132 ../../user-api/sessions.rst:214
#: ../../user-api/sessions.rst:227 ../../user-api/sessions.rst:239
#: ../../user-api/sessions.rst:274 ../../user-api/sessions.rst:287
#: ../../user-api/sessions.rst:299 ../../user-api/sessions.rst:324
#: ../../user-api/sessions.rst:337 ../../user-api/vfolders.rst:47
#: ../../user-api/vfolders.rst:95 ../../user-api/vfolders.rst:139
#: ../../user-api/vfolders.rst:166 ../../user-api/vfolders.rst:224
#: ../../user-api/vfolders.rst:237 ../../user-api/vfolders.rst:282
#: ../../user-api/vfolders.rst:294 ../../user-api/vfolders.rst:319
#: ../../user-api/vfolders.rst:334 ../../user-api/vfolders.rst:374
#: ../../user-api/vfolders.rst:391 ../../user-api/vfolders.rst:424
#: ../../user-api/vfolders.rst:440 ../../user-api/vfolders.rst:471
#: ../../user-api/vfolders.rst:486 ../../user-api/vfolders.rst:527
#: ../../user-api/vfolders.rst:542 ../../user-api/vfolders.rst:581
#: ../../user-api/vfolders.rst:599 ../../user-api/vfolders.rst:630
#: ../../user-api/vfolders.rst:665 ../../user-api/vfolders.rst:684
#: ../../user-api/vfolders.rst:721 ../../user-api/vfolders.rst:737
#: ../../user-api/vfolders.rst:774 ../../user-api/vfolders.rst:787
msgid "Description"
msgstr "설명"

#: ../../user-api/events.rst:32 ../../user-api/events.rst:99
msgid "``sessionId``"
msgstr "``sessionId``"

#: ../../user-api/events.rst:33 ../../user-api/exec-batch.rst:78
#: ../../user-api/exec-batch.rst:152 ../../user-api/exec-batch.rst:211
#: ../../user-api/exec-query.rst:27 ../../user-api/exec-query.rst:269
#: ../../user-api/exec-query.rst:359 ../../user-api/exec-stream.rst:59
#: ../../user-api/exec-stream.rst:62 ../../user-api/service-ports.rst:68
#: ../../user-api/service-ports.rst:71 ../../user-api/service-ports.rst:101
#: ../../user-api/service-ports.rst:104 ../../user-api/sessions.rst:35
#: ../../user-api/sessions.rst:150 ../../user-api/sessions.rst:216
#: ../../user-api/sessions.rst:276 ../../user-api/sessions.rst:326
#: ../../user-api/vfolders.rst:184 ../../user-api/vfolders.rst:723
#: ../../user-api/vfolders.rst:776
msgid "``slug``"
msgstr "``slug``"

#: ../../user-api/events.rst:34
msgid ""
"The session ID to monitor the lifecycle events. If set ``\"*\"``, the API"
" will stream events from all kernels visible to the client depending on "
"the client's role and permissions."
msgstr ""
"라이프사이클 이벤트를 모니터링하기 위한 세션 ID 입니다. ``\"*``로 설정하면, "
"API는 클라이언트의 역할과 권한에 따라 클라이언트에 보여지는 모든 커널에서 "
"이벤트를 스트리밍합니다."

#: ../../user-api/events.rst:37 ../../user-api/events.rst:101
msgid "``ownerAccessKey``"
msgstr "``ownerAccessKey``"

#: ../../user-api/events.rst:38 ../../user-api/events.rst:43
#: ../../user-api/exec-batch.rst:84 ../../user-api/exec-batch.rst:87
#: ../../user-api/exec-batch.rst:155 ../../user-api/exec-batch.rst:179
#: ../../user-api/exec-batch.rst:182 ../../user-api/exec-batch.rst:185
#: ../../user-api/exec-query.rst:30 ../../user-api/exec-query.rst:33
#: ../../user-api/exec-query.rst:37 ../../user-api/exec-query.rst:272
#: ../../user-api/exec-query.rst:275 ../../user-api/exec-query.rst:278
#: ../../user-api/sessions.rst:28 ../../user-api/sessions.rst:73
#: ../../user-api/sessions.rst:79 ../../user-api/sessions.rst:92
#: ../../user-api/sessions.rst:154 ../../user-api/sessions.rst:241
#: ../../user-api/vfolders.rst:107 ../../user-api/vfolders.rst:142
#: ../../user-api/vfolders.rst:145 ../../user-api/vfolders.rst:187
#: ../../user-api/vfolders.rst:190 ../../user-api/vfolders.rst:226
#: ../../user-api/vfolders.rst:321 ../../user-api/vfolders.rst:324
#: ../../user-api/vfolders.rst:376 ../../user-api/vfolders.rst:426
#: ../../user-api/vfolders.rst:429 ../../user-api/vfolders.rst:473
#: ../../user-api/vfolders.rst:476 ../../user-api/vfolders.rst:529
#: ../../user-api/vfolders.rst:583 ../../user-api/vfolders.rst:667
#: ../../user-api/vfolders.rst:670 ../../user-api/vfolders.rst:754
#: ../../user-api/vfolders.rst:801
msgid "``str``"
msgstr "``str``"

#: ../../user-api/events.rst:39
msgid ""
"*(optional)* The access key of the owner of the specified session, since "
"different access keys (users) may share a same session ID for different "
"session instances. You can specify this only when the client is either a "
"domain admin or a superadmin."
msgstr ""
"*(선택사항)* 다른 액세스 키(사용자)가 다른 세션 인스턴스에 대해 동일한 세션 아이디를 "
"공유할 수 있기 때문에 지정된 세션 소유자의 접근 키 입니다. 도메인 소유자나 슈퍼관리자만이 "
"이를 지정할 수 있습니다."
#: ../../user-api/events.rst:42 ../../user-api/sessions.rst:72
msgid "``group``"
msgstr "``group``"

#: ../../user-api/events.rst:44
msgid ""
"The group name to filter the lifecycle events. If set ``\"*\"``, the API "
"will stream events from all kernels visible to the client depending on "
"the client's role and permissions."
msgstr ""
"라이프사이클 이벤트를 필터링할 그룹 이름입니다. ``\"*``로 설정하면, "
"API는 클라이언트의 역할과 권한에 따라 클라이언트에 보여지는 모든 커널에서 "
"이벤트를 스트리밍합니다."

#: ../../user-api/events.rst:49
msgid "Responses"
msgstr "응답"

#: ../../user-api/events.rst:51
msgid ""
"The response is a continuous stream of UTF-8 text lines following the "
"``text/event-stream`` format. Each event is composed of the event type "
"and data, where the data part is encoded as JSON."
msgstr ""
"응답은 ``text/event-stream`` 형식을 따르는 연속적인 여러 줄의 UTF-8 텍스트 스트림입니다. 각 이벤트는 이벤트 "
"타입과 데이터로 구성되어 있으며, 데이터는 JSON 으로 인코딩 됩니다. "

#: ../../user-api/events.rst:54
msgid "Possible event names (more events may be added in the future):"
msgstr "가능한 이벤트 명(추후 더 많은 이벤트가 추가될 수 있습니다)"

#: ../../user-api/events.rst:60
msgid "Event Name"
msgstr "이벤트 명"

#: ../../user-api/events.rst:62
#, fuzzy
msgid "``kernel_preparing``"
msgstr "커널-준비"

#: ../../user-api/events.rst:63
msgid ""
"The session is just scheduled from the job queue and got an agent "
"resource allocation."
msgstr "세션이 방금 작업 큐에 스케쥴링 되었고, 에이전트로부터 자원 할당을 받았습니다."

#: ../../user-api/events.rst:64
#, fuzzy
msgid "``kernel_pulling``"
msgstr "커널-가져오기"

#: ../../user-api/events.rst:65
msgid ""
"The session begins pulling the kernel image (usually from a Docker "
"registry) to the scheduled agent."
msgstr "세션이 (대개 도커 레지스트리로부터 온) 커널 이미지를 예약된 에이전트로 가져오기 시작합니다."

#: ../../user-api/events.rst:66
#, fuzzy
msgid "``kernel_creating``"
msgstr "커널-생성"

#: ../../user-api/events.rst:67
msgid ""
"The session is being created as containers (or other entities in "
"different agent backends)."
msgstr "세션이 컨테이너 (또는 다른 에이전트 백엔드의 다른 객체로) 생성되는 중입니다."

#: ../../user-api/events.rst:68
#, fuzzy
msgid "``kernel_started``"
msgstr "커널-시작됨"

#: ../../user-api/events.rst:69
msgid "The session becomes ready to execute codes."
msgstr "세션에서 코드를 실행할 준비를 마쳤습니다."

#: ../../user-api/events.rst:70
#, fuzzy
msgid "``kernel_terminated``"
msgstr "커널-종료"

#: ../../user-api/events.rst:71
msgid "The session has terminated."
msgstr "세션이 종료되었습니다."

#: ../../user-api/events.rst:73
msgid "When using the EventSource API, you should add event listeners as follows:"
msgstr "이벤트소스 API를 사용할 경우, 다음을 따르는 이벤트 리스너를 추가해주십시오 : "

#: ../../user-api/events.rst:86
msgid ""
"The EventSource API must be used with the session-based authentication "
"mode (when the endpoint is a console-server) which uses the browser "
"cookies. Otherwise, you need to manually implement the event stream "
"parser using the standard fetch API running against the manager server."
msgstr ""
"이벤트소스 API는 (콘솔-서버가 종단점 일 때) 반드시 브라우저 쿠키를 사용하는 세션-기반 인증 모드여야 합니다. 다른 방식으로는"
" 관리자 서버에 대해 실행되는 표준 fetch API를 사용해 이벤트 스트림 파서를 수동으로 구현해야 합니다."

#: ../../user-api/events.rst:91
msgid ""
"The event data contains a JSON string like this (more fields may be added"
" in the future):"
msgstr "이벤트 데이터는 다음과 같은 JSON 문자열로 구성됩니다 (추후 더 많은 필드가 추가될 수 있음) : "

#: ../../user-api/events.rst:97
msgid "Field Name"
msgstr "필드 명"

#: ../../user-api/events.rst:100
msgid "The source session ID."
msgstr "소스 세션 아이디"

#: ../../user-api/events.rst:102
msgid "The access key who owns the session."
msgstr "세션을 소유하고 있는 액세스 키"

#: ../../user-api/events.rst:103
msgid "``reason``"
msgstr "``reason``"

#: ../../user-api/events.rst:104
msgid ""
"A short string that describes why the event happened. This may be "
"``null`` or an empty string."
msgstr ""
"이 이벤트가 왜 발생했는지에 대한 짧은 문자열입니다. 이것은 "
"``null``이거나 빈 문자열일 수 있습니다."

#: ../../user-api/events.rst:106 ../../user-api/exec-batch.rst:125
#: ../../user-api/exec-query.rst:73 ../../user-api/exec-query.rst:321
msgid "``result``"
msgstr "``result``"

#: ../../user-api/events.rst:107
msgid ""
"Only present for ``kernel-terminated`` events. Only meaningful for batch-"
"type sessions. Either one of: ``\"UNDEFINED\"``, ``\"SUCCESS\"``, "
"``\"FAILURE\"``"
msgstr ""
"``kernel-terminated`` 이벤트만을 위해 존재합니다. 배치-타입 세션에만 유의미합니다."
"다음 중 하나:  ``\"UNDEFINED\"``, ``\"SUCCESS\"``, ``\"FAILURE\"``"

#: ../../user-api/exec-batch.rst:2
msgid "Code Execution (Batch Mode)"
msgstr "코드 실행 (배치 모드)"

#: ../../user-api/exec-batch.rst:4
msgid ""
"Some kernels provide the batch mode, which offers an explicit build step "
"required for multi-module programs or compiled programming languages. In "
"this mode, you first upload files in prior to execution."
msgstr ""
"일부 커널은 배치 모드를 제공하는데, 이것은 다중 모듈 프로그램이나 컴파일된 프로그래밍 언어에 필요한 "
"명시적인 빌드 단계를 제공합니다. 이 모드에서는 실행 전에 먼저 파일을 업로드합니다."

#: ../../user-api/exec-batch.rst:9
msgid "Uploading files"
msgstr "파일 업로드"

#: ../../user-api/exec-batch.rst:11
msgid "URI: ``/session/:id/upload``"
msgstr "URI: ``/session/:id/upload``"

#: ../../user-api/exec-batch.rst:12 ../../user-api/exec-batch.rst:65
#: ../../user-api/exec-query.rst:8 ../../user-api/exec-query.rst:256
#: ../../user-api/exec-query.rst:346 ../../user-api/resource-presets.rst:59
#: ../../user-api/sessions.rst:12 ../../user-api/vfolders.rst:126
#: ../../user-api/vfolders.rst:359 ../../user-api/vfolders.rst:409
#: ../../user-api/vfolders.rst:654 ../../user-api/vfolders.rst:710
msgid "Method: ``POST``"
msgstr "Method: ``POST``"

#: ../../user-api/exec-batch.rst:17
msgid ""
"Upload files to the session. You may upload multiple files at once using "
"multi-part form-data encoding in the request body (RFC 1867/2388). The "
"uploaded files are placed under ``/home/work`` directory (which is the "
"home directory for all kernels by default), and existing files are always"
" overwritten. If the filename has a directory part, non-existing "
"directories will be auto-created. The path may be either absolute or "
"relative, but only sub-directories under ``/home/work`` is allowed to be "
"created."
msgstr ""
"세션에 파일을 업로드 하십시오. 요청 본문 (RFC 1867/2388)에서 다중-파트 폼-데이터 인코딩을 사용하여 "
"한번에 다중 파일들을 업로드 할 수 있습니다. 업로드된 파일들은 ``/home/work`` 디렉터리"
"(기본적으로 모든 커널의 홈 디렉터리)하위에 위치하며, 기존 파일은 항상 덮어씁니다."
"파일명에 디렉터리 부분이 있다면, 존재하지 않는 디렉터리가 자동-생성됩니다. 경로는 절대적이거나 "
"상대적일 수 있지만, ``/home/work``하위에 하위-디렉터리들만 생성될 수 있습니다."

#: ../../user-api/exec-batch.rst:26
msgid ""
"This API is for uploading frequently-changing source files in prior to "
"batch-mode execution. All files uploaded via this API is deleted when the"
" kernel terminates. Use :doc:`virtual folders </user-api/vfolders>` to "
"store and access larger, persistent, static data and library files for "
"your codes."
msgstr ""
"이 API는 배치-모드 실행 전에 자주 변경되는 소스 파일을 업로드 하기 위한 것입니다."
"커널이 종료되면 이 API를 통해 업로드된 모든 파일이 삭제됩니다. 코드를 위해 "
:doc:`virtual folders </user-api/vfolders>`를 사용하여 더 크고, 영구적인, 정적 데이터 및 "
"라이브러리 파일을 저장하고 액세스하십시오."

#: ../../user-api/exec-batch.rst:33
msgid ""
"You cannot upload files to mounted virtual folders using this API "
"directly. However, you may copy/move the generated files to virtual "
"folders in your build script or the main program for later uses."
msgstr ""
"이 API를 사용해서 탑재된 가상 폴더에 직접적으로 파일을 업로드할 수 없다."
"그러나, 이 후 사용을 위해서 빌드 스크립트나 메인 프로그램 안의 가상폴더로 생성된 파일을 "
"복사/이동할 수 있다."

#: ../../user-api/exec-batch.rst:36
msgid "There are several limits on this API:"
msgstr ""

#: ../../user-api/exec-batch.rst:41
msgid "The maximum size of each file"
msgstr ""

#: ../../user-api/exec-batch.rst:42
msgid "1 MiB"
msgstr ""

#: ../../user-api/exec-batch.rst:43
msgid "The number of files per upload request"
msgstr ""

#: ../../user-api/exec-batch.rst:44
msgid "20"
msgstr ""

#: ../../user-api/exec-batch.rst:47 ../../user-api/exec-batch.rst:106
#: ../../user-api/exec-batch.rst:159 ../../user-api/exec-batch.rst:219
#: ../../user-api/exec-query.rst:54 ../../user-api/exec-query.rst:302
#: ../../user-api/exec-query.rst:363 ../../user-api/resource-presets.rst:27
#: ../../user-api/resource-presets.rst:67 ../../user-api/sessions.rst:125
#: ../../user-api/sessions.rst:220 ../../user-api/sessions.rst:280
#: ../../user-api/sessions.rst:330 ../../user-api/vfolders.rst:40
#: ../../user-api/vfolders.rst:88 ../../user-api/vfolders.rst:159
#: ../../user-api/vfolders.rst:230 ../../user-api/vfolders.rst:287
#: ../../user-api/vfolders.rst:328 ../../user-api/vfolders.rst:385
#: ../../user-api/vfolders.rst:434 ../../user-api/vfolders.rst:480
#: ../../user-api/vfolders.rst:536 ../../user-api/vfolders.rst:593
#: ../../user-api/vfolders.rst:623 ../../user-api/vfolders.rst:677
#: ../../user-api/vfolders.rst:730 ../../user-api/vfolders.rst:780
msgid "Response"
msgstr ""

#: ../../user-api/exec-batch.rst:53 ../../user-api/exec-batch.rst:112
#: ../../user-api/exec-batch.rst:164 ../../user-api/exec-batch.rst:224
#: ../../user-api/exec-query.rst:60 ../../user-api/exec-query.rst:308
#: ../../user-api/exec-query.rst:369 ../../user-api/resource-presets.rst:33
#: ../../user-api/resource-presets.rst:73 ../../user-api/sessions.rst:131
#: ../../user-api/sessions.rst:226 ../../user-api/sessions.rst:286
#: ../../user-api/sessions.rst:336 ../../user-api/vfolders.rst:46
#: ../../user-api/vfolders.rst:94 ../../user-api/vfolders.rst:165
#: ../../user-api/vfolders.rst:236 ../../user-api/vfolders.rst:293
#: ../../user-api/vfolders.rst:333 ../../user-api/vfolders.rst:390
#: ../../user-api/vfolders.rst:439 ../../user-api/vfolders.rst:485
#: ../../user-api/vfolders.rst:541 ../../user-api/vfolders.rst:598
#: ../../user-api/vfolders.rst:629 ../../user-api/vfolders.rst:683
#: ../../user-api/vfolders.rst:736 ../../user-api/vfolders.rst:786
msgid "HTTP Status Code"
msgstr ""

#: ../../user-api/exec-batch.rst:55
msgid "204 OK"
msgstr ""

#: ../../user-api/exec-batch.rst:56 ../../user-api/exec-batch.rst:167
#: ../../user-api/exec-batch.rst:227 ../../user-api/vfolders.rst:49
#: ../../user-api/vfolders.rst:97 ../../user-api/vfolders.rst:336
#: ../../user-api/vfolders.rst:393 ../../user-api/vfolders.rst:442
#: ../../user-api/vfolders.rst:488 ../../user-api/vfolders.rst:544
#: ../../user-api/vfolders.rst:601 ../../user-api/vfolders.rst:632
#: ../../user-api/vfolders.rst:686 ../../user-api/vfolders.rst:739
#: ../../user-api/vfolders.rst:789
msgid "Success."
msgstr ""

#: ../../user-api/exec-batch.rst:57 ../../user-api/vfolders.rst:169
#: ../../user-api/vfolders.rst:394 ../../user-api/vfolders.rst:443
#: ../../user-api/vfolders.rst:602 ../../user-api/vfolders.rst:687
#: ../../user-api/vfolders.rst:740
msgid "400 Bad Request"
msgstr ""

#: ../../user-api/exec-batch.rst:58
msgid ""
"Returned when one of the uploaded file exeeds the size limit or there are"
" too many files."
msgstr ""

#: ../../user-api/exec-batch.rst:62
msgid "Executing with Build Step"
msgstr ""

#: ../../user-api/exec-batch.rst:64 ../../user-api/sessions.rst:198
#: ../../user-api/sessions.rst:260 ../../user-api/sessions.rst:308
msgid "URI: ``/session/:id``"
msgstr ""

#: ../../user-api/exec-batch.rst:77 ../../user-api/exec-batch.rst:151
#: ../../user-api/exec-batch.rst:210 ../../user-api/exec-query.rst:26
#: ../../user-api/exec-query.rst:268 ../../user-api/exec-query.rst:358
#: ../../user-api/exec-stream.rst:58 ../../user-api/service-ports.rst:67
#: ../../user-api/service-ports.rst:100 ../../user-api/sessions.rst:215
#: ../../user-api/sessions.rst:275 ../../user-api/sessions.rst:325
msgid "``:id``"
msgstr ""

#: ../../user-api/exec-batch.rst:79 ../../user-api/exec-batch.rst:153
#: ../../user-api/exec-batch.rst:212 ../../user-api/sessions.rst:217
#: ../../user-api/sessions.rst:277 ../../user-api/sessions.rst:327
#, fuzzy
msgid "The session ID."
msgstr "세션이 종료되었습니다."

#: ../../user-api/exec-batch.rst:80 ../../user-api/exec-query.rst:29
msgid "``mode``"
msgstr ""

#: ../../user-api/exec-batch.rst:81
msgid "``enum[str]``"
msgstr ""

#: ../../user-api/exec-batch.rst:82
msgid "A constant string ``\"batch\"``."
msgstr ""

#: ../../user-api/exec-batch.rst:83 ../../user-api/exec-query.rst:32
#: ../../user-api/exec-query.rst:271
msgid "``code``"
msgstr ""

#: ../../user-api/exec-batch.rst:85
msgid "Must be an empty string ``\"\"``."
msgstr ""

#: ../../user-api/exec-batch.rst:86 ../../user-api/exec-query.rst:36
msgid "``runId``"
msgstr ""

#: ../../user-api/exec-batch.rst:88 ../../user-api/exec-query.rst:38
msgid ""
"A string of client-side unique identifier for this particular run. For "
"more details about the concept of a run, see :ref:`code-execution-model`."
" If not given, the API server will assign a random one in the first "
"response and the client must use it for the same run afterwards."
msgstr ""

#: ../../user-api/exec-batch.rst:91
msgid "``options``"
msgstr ""

#: ../../user-api/exec-batch.rst:92 ../../user-api/exec-batch.rst:126
#: ../../user-api/exec-query.rst:74 ../../user-api/sessions.rst:85
#: ../../user-api/sessions.rst:301 ../../user-api/vfolders.rst:252
msgid "``object``"
msgstr ""

#: ../../user-api/exec-batch.rst:93
msgid ":ref:`batch-execution-query-object`."
msgstr ""

#: ../../user-api/exec-batch.rst:95 ../../user-api/sessions.rst:96
#: ../../user-api/sessions.rst:180 ../../user-api/vfolders.rst:62
#: ../../user-api/vfolders.rst:113 ../../user-api/vfolders.rst:148
#: ../../user-api/vfolders.rst:194
msgid "Example:"
msgstr ""

#: ../../user-api/exec-batch.rst:114 ../../user-api/exec-batch.rst:166
#: ../../user-api/exec-batch.rst:226 ../../user-api/exec-query.rst:62
#: ../../user-api/exec-query.rst:310 ../../user-api/resource-presets.rst:35
#: ../../user-api/resource-presets.rst:75 ../../user-api/sessions.rst:133
#: ../../user-api/sessions.rst:228 ../../user-api/vfolders.rst:48
#: ../../user-api/vfolders.rst:96 ../../user-api/vfolders.rst:238
#: ../../user-api/vfolders.rst:335 ../../user-api/vfolders.rst:487
#: ../../user-api/vfolders.rst:543 ../../user-api/vfolders.rst:600
#: ../../user-api/vfolders.rst:631 ../../user-api/vfolders.rst:685
#: ../../user-api/vfolders.rst:738 ../../user-api/vfolders.rst:788
msgid "200 OK"
msgstr ""

#: ../../user-api/exec-batch.rst:115 ../../user-api/exec-query.rst:63
#: ../../user-api/exec-query.rst:311
msgid ""
"The kernel has responded with the execution result. The response body "
"contains a JSON object as described below."
msgstr ""

#: ../../user-api/exec-batch.rst:122 ../../user-api/exec-batch.rst:175
#: ../../user-api/exec-query.rst:70 ../../user-api/exec-query.rst:318
#: ../../user-api/resource-presets.rst:42
#: ../../user-api/resource-presets.rst:84 ../../user-api/sessions.rst:146
#: ../../user-api/vfolders.rst:55 ../../user-api/vfolders.rst:103
#: ../../user-api/vfolders.rst:180 ../../user-api/vfolders.rst:248
#: ../../user-api/vfolders.rst:345 ../../user-api/vfolders.rst:497
#: ../../user-api/vfolders.rst:553 ../../user-api/vfolders.rst:638
#: ../../user-api/vfolders.rst:696 ../../user-api/vfolders.rst:750
#: ../../user-api/vfolders.rst:797
msgid "Fields"
msgstr ""

#: ../../user-api/exec-batch.rst:124 ../../user-api/exec-batch.rst:177
#: ../../user-api/exec-query.rst:72 ../../user-api/exec-query.rst:320
#: ../../user-api/resource-presets.rst:44
#: ../../user-api/resource-presets.rst:86 ../../user-api/sessions.rst:148
#: ../../user-api/vfolders.rst:57 ../../user-api/vfolders.rst:105
#: ../../user-api/vfolders.rst:182 ../../user-api/vfolders.rst:250
#: ../../user-api/vfolders.rst:347 ../../user-api/vfolders.rst:499
#: ../../user-api/vfolders.rst:555 ../../user-api/vfolders.rst:640
#: ../../user-api/vfolders.rst:698 ../../user-api/vfolders.rst:752
#: ../../user-api/vfolders.rst:799
msgid "Values"
msgstr ""

#: ../../user-api/exec-batch.rst:127 ../../user-api/exec-query.rst:75
msgid ":ref:`execution-result-object`."
msgstr ""

#: ../../user-api/exec-batch.rst:131
msgid "Listing Files"
msgstr ""

#: ../../user-api/exec-batch.rst:133
msgid ""
"Once files are uploaded to the session or generated during the execution "
"of the code, there is a need to identify what files actually are in the "
"current session. In this case, use this API to get the list of files of "
"your compute sesison."
msgstr ""

#: ../../user-api/exec-batch.rst:138
msgid "URI: ``/session/:id/files``"
msgstr ""

#: ../../user-api/exec-batch.rst:154 ../../user-api/vfolders.rst:323
#: ../../user-api/vfolders.rst:428
msgid "``path``"
msgstr ""

#: ../../user-api/exec-batch.rst:156
msgid "Path inside the session (default: ``/home/work``)."
msgstr ""

#: ../../user-api/exec-batch.rst:168 ../../user-api/sessions.rst:230
#: ../../user-api/sessions.rst:290 ../../user-api/sessions.rst:340
#: ../../user-api/vfolders.rst:240 ../../user-api/vfolders.rst:297
#: ../../user-api/vfolders.rst:337 ../../user-api/vfolders.rst:397
#: ../../user-api/vfolders.rst:445 ../../user-api/vfolders.rst:489
#: ../../user-api/vfolders.rst:545 ../../user-api/vfolders.rst:604
#: ../../user-api/vfolders.rst:689 ../../user-api/vfolders.rst:743
#: ../../user-api/vfolders.rst:790
msgid "404 Not Found"
msgstr ""

#: ../../user-api/exec-batch.rst:169
msgid "There is no such path."
msgstr ""

#: ../../user-api/exec-batch.rst:178 ../../user-api/exec-batch.rst:213
#: ../../user-api/vfolders.rst:348 ../../user-api/vfolders.rst:531
#: ../../user-api/vfolders.rst:585
msgid "``files``"
msgstr ""

#: ../../user-api/exec-batch.rst:180
msgid "Stringified json containing list of files."
msgstr ""

#: ../../user-api/exec-batch.rst:181
msgid "``folder_path``"
msgstr ""

#: ../../user-api/exec-batch.rst:183
msgid "Absolute path inside session."
msgstr ""

#: ../../user-api/exec-batch.rst:184
msgid "``errors``"
msgstr ""

#: ../../user-api/exec-batch.rst:186
msgid "Any errors occurred during scanning the specified path."
msgstr ""

#: ../../user-api/exec-batch.rst:190
msgid "Downloading Files"
msgstr ""

#: ../../user-api/exec-batch.rst:192
msgid "Download files from your compute session."
msgstr ""

#: ../../user-api/exec-batch.rst:194
msgid ""
"The response contents are multiparts with tarfile binaries. Post-"
"processing, such as unpacking and save them, should be handled by the "
"client."
msgstr ""

#: ../../user-api/exec-batch.rst:197
msgid "URI: ``/session/:id/download``"
msgstr ""

#: ../../user-api/exec-batch.rst:214 ../../user-api/exec-query.rst:322
#: ../../user-api/vfolders.rst:110 ../../user-api/vfolders.rst:532
#: ../../user-api/vfolders.rst:586
msgid "``list[str]``"
msgstr ""

#: ../../user-api/exec-batch.rst:215
msgid ""
"File paths inside the kernel container to download. (maximum 5 files at "
"once)"
msgstr ""

#: ../../user-api/exec-query.rst:2
msgid "Code Execution (Query Mode)"
msgstr ""

#: ../../user-api/exec-query.rst:5
msgid "Executing Snippet"
msgstr ""

#: ../../user-api/exec-query.rst:7
msgid "URI: ``/kernel/:id``"
msgstr ""

#: ../../user-api/exec-query.rst:10
msgid ""
"Executes a snippet of user code using the specified session. Each "
"execution request to a same session may have side-effects to subsequent "
"executions. For instance, setting a global variable in a request and "
"reading the variable in another request is completely legal. It is the "
"job of the user (or the front-end) to gaurantee the correct execution "
"order of multiple interdependent requests. When the session is terminated"
" or restarted, all such volatile states vanish."
msgstr ""

#: ../../user-api/exec-query.rst:28 ../../user-api/exec-query.rst:270
#: ../../user-api/exec-query.rst:360 ../../user-api/exec-stream.rst:60
#: ../../user-api/service-ports.rst:69 ../../user-api/service-ports.rst:102
msgid "The kernel ID."
msgstr ""

#: ../../user-api/exec-query.rst:31
msgid "A constant string ``\"query\"``."
msgstr ""

#: ../../user-api/exec-query.rst:34
msgid ""
"A string of user-written code. All non-ASCII data must be encoded in "
"UTF-8 or any format acceptable by the kernel."
msgstr ""

#: ../../user-api/exec-query.rst:42 ../../user-api/exec-query.rst:287
#: ../../user-api/exec-query.rst:331
msgid "**Example:**"
msgstr ""

#: ../../user-api/exec-query.rst:79
msgid ""
"Even when the user code raises exceptions, such queries are treated as "
"successful execution. i.e., The failure of this API means that our API "
"subsystem had errors, not the user codes."
msgstr ""

#: ../../user-api/exec-query.rst:84
msgid ""
"If the user code tries to breach the system, causes crashs (e.g., "
"segmentation fault), or runs too long (timeout), the session is "
"automatically terminated. In such cases, you will get incomplete console "
"logs with ``\"finished\"`` status earlier than expected. Depending on "
"situation, the ``result.stderr`` may also contain specific error "
"information."
msgstr ""

#: ../../user-api/exec-query.rst:89
msgid ""
"Here we demonstrate a few example returns when various Python codes are "
"executed."
msgstr ""

#: ../../user-api/exec-query.rst:91
msgid "**Example: Simple return.**"
msgstr ""

#: ../../user-api/exec-query.rst:110
msgid "**Example: Runtime error.**"
msgstr ""

#: ../../user-api/exec-query.rst:132
msgid "**Example: Multimedia output.**"
msgstr ""

#: ../../user-api/exec-query.rst:134
msgid ""
"Media outputs are also mixed with other console outputs according to "
"their execution order."
msgstr ""

#: ../../user-api/exec-query.rst:161
msgid "**Example: Continuation results.**"
msgstr ""

#: ../../user-api/exec-query.rst:184
msgid "Here you should make another API query with the empty ``code`` field."
msgstr ""

#: ../../user-api/exec-query.rst:199
msgid "Again."
msgstr ""

#: ../../user-api/exec-query.rst:214
msgid "**Example: User input.**"
msgstr ""

#: ../../user-api/exec-query.rst:237
msgid ""
"You should make another API query with the ``code`` field filled with the"
" user input."
msgstr ""

#: ../../user-api/exec-query.rst:253
msgid "Auto-completion"
msgstr ""

#: ../../user-api/exec-query.rst:255
msgid "URI: ``/kernel/:id/complete``"
msgstr ""

#: ../../user-api/exec-query.rst:273
msgid "A string containing the code until the current cursor position."
msgstr ""

#: ../../user-api/exec-query.rst:274
msgid "``options.post``"
msgstr ""

#: ../../user-api/exec-query.rst:276
msgid "A string containing the code after the current cursor position."
msgstr ""

#: ../../user-api/exec-query.rst:277
msgid "``options.line``"
msgstr ""

#: ../../user-api/exec-query.rst:279
msgid "A string containing the content of the current line."
msgstr ""

#: ../../user-api/exec-query.rst:280
msgid "``options.row``"
msgstr ""

#: ../../user-api/exec-query.rst:281 ../../user-api/exec-query.rst:284
#: ../../user-api/sessions.rst:54 ../../user-api/sessions.rst:250
msgid "``int``"
msgstr ""

#: ../../user-api/exec-query.rst:282
msgid "An integer indicating the line number (0-based) of the cursor."
msgstr ""

#: ../../user-api/exec-query.rst:283
msgid "``options.col``"
msgstr ""

#: ../../user-api/exec-query.rst:285
msgid ""
"An integer indicating the column number (0-based) in the current line of "
"the cursor."
msgstr ""

#: ../../user-api/exec-query.rst:324
msgid ""
"An ordered list containing the possible auto-completion matches as "
"strings. This may be empty if the current kernel does not implement auto-"
"completion or no matches have been found."
msgstr ""

#: ../../user-api/exec-query.rst:328
msgid ""
"Selecting a match and merging it into the code text are up to the front-"
"end implementation."
msgstr ""

#: ../../user-api/exec-query.rst:343
msgid "Interrupt"
msgstr ""

#: ../../user-api/exec-query.rst:345
msgid "URI: ``/kernel/:id/interrupt``"
msgstr ""

#: ../../user-api/exec-query.rst:371 ../../user-api/sessions.rst:288
#: ../../user-api/sessions.rst:338 ../../user-api/vfolders.rst:295
msgid "204 No Content"
msgstr ""

#: ../../user-api/exec-query.rst:372
msgid ""
"Sent the interrupt signal to the kernel. Note that this does *not* "
"guarantee the effectiveness of the interruption."
msgstr ""

#: ../../user-api/exec-stream.rst:4
msgid "Code Execution (Streaming)"
msgstr ""

#: ../../user-api/exec-stream.rst:6
msgid ""
"The streaming mode provides a lightweight and interactive method to "
"connect with the kernel containers."
msgstr ""

#: ../../user-api/exec-stream.rst:10
msgid "Code Execution"
msgstr ""

#: ../../user-api/exec-stream.rst:11
msgid "URI: ``/stream/kernel/:id/execute``"
msgstr ""

#: ../../user-api/exec-stream.rst:12 ../../user-api/exec-stream.rst:28
#: ../../user-api/service-ports.rst:46 ../../user-api/service-ports.rst:79
msgid "Method: ``GET`` upgraded to WebSockets"
msgstr ""

#: ../../user-api/exec-stream.rst:14
msgid ""
"This is a real-time streaming version of :doc:`exec-batch` and :doc"
":`exec-query` which uses long polling via HTTP."
msgstr ""

#: ../../user-api/exec-stream.rst:17
msgid "(under construction)"
msgstr ""

#: ../../user-api/exec-stream.rst:25
msgid "Terminal Emulation"
msgstr ""

#: ../../user-api/exec-stream.rst:27
msgid "URI: ``/stream/kernel/:id/pty?app=:service``"
msgstr ""

#: ../../user-api/exec-stream.rst:30
msgid ""
"This endpoint provides a duplex continuous stream of JSON objects via the"
" native WebSocket. Although WebSocket supports binary streams, we "
"currently rely on TEXT messages only conveying JSON payloads to avoid "
"quirks in typed array support in Javascript across different browsers."
msgstr ""

#: ../../user-api/exec-stream.rst:35 ../../user-api/service-ports.rst:51
#: ../../user-api/service-ports.rst:84
msgid ""
"The service name should be taken from the list of :ref:`service port "
"objects <service-port-object>` returned by :ref:`the session creation API"
" <create-session-api>`."
msgstr ""

#: ../../user-api/exec-stream.rst:41
msgid ""
"We do *not* provide any legacy WebSocket emulation interfaces such as "
"socket.io or SockJS. You need to set up your own proxy if you want to "
"support legacy browser users."
msgstr ""

#: ../../user-api/exec-stream.rst:46
msgid "Added the ``service`` query parameter."
msgstr ""

#: ../../user-api/exec-stream.rst:61 ../../user-api/service-ports.rst:70
#: ../../user-api/service-ports.rst:103
msgid "``:service``"
msgstr ""

#: ../../user-api/exec-stream.rst:63 ../../user-api/service-ports.rst:72
#: ../../user-api/service-ports.rst:105
msgid "The service name to connect."
msgstr ""

#: ../../user-api/exec-stream.rst:66
msgid "Client-to-Server Protocol"
msgstr ""

#: ../../user-api/exec-stream.rst:68
msgid "The endpoint accepts the following four types of input messages."
msgstr ""

#: ../../user-api/exec-stream.rst:71
msgid "Standard input stream"
msgstr ""

#: ../../user-api/exec-stream.rst:73
msgid ""
"All ASCII (and UTF-8) inputs must be encoded as base64 strings. The "
"characters may include control characters as well."
msgstr ""

#: ../../user-api/exec-stream.rst:84
msgid "Terminal resize"
msgstr ""

#: ../../user-api/exec-stream.rst:86
msgid ""
"Set the terminal size to the given number of rows and columns. You should"
" calculate them by yourself."
msgstr ""

#: ../../user-api/exec-stream.rst:89
msgid ""
"For instance, for web-browsers, you may do a simple math by measuring the"
" width and height of a temporarily created, invisible HTML element with "
"the (monospace) font styles same to the terminal container element that "
"contains only a single ASCII character."
msgstr ""

#: ../../user-api/exec-stream.rst:103
msgid "Ping"
msgstr ""

#: ../../user-api/exec-stream.rst:105
msgid ""
"Use this to keep the kernel alive (preventing it from auto-terminated by "
"idle timeouts) by sending pings periodically while the user-side browser "
"is open."
msgstr ""

#: ../../user-api/exec-stream.rst:115
msgid "Restart"
msgstr ""

#: ../../user-api/exec-stream.rst:117
msgid ""
"Use this to restart the kernel without affecting the working directory "
"and usage counts. Useful when your foreground terminal program does not "
"respond for whatever reasons."
msgstr ""

#: ../../user-api/exec-stream.rst:128
msgid "Server-to-Client Protocol"
msgstr ""

#: ../../user-api/exec-stream.rst:131
msgid "Standard output/error stream"
msgstr ""

#: ../../user-api/exec-stream.rst:133
msgid ""
"Since the terminal is an output device, all stdout/stderr outputs are "
"merged into a single stream as we see in real terminals. This means there"
" is no way to distinguish stdout and stderr in the client-side, unless "
"your kernel applies some special formatting to distinguish them (e.g., "
"make all stderr otuputs red)."
msgstr ""

#: ../../user-api/exec-stream.rst:139
msgid ""
"The terminal output is compatible with xterm (including 256-color "
"support)."
msgstr ""

#: ../../user-api/exec-stream.rst:149
msgid "Server-side errors"
msgstr ""

#: ../../user-api/intro.rst:2
msgid "Introduction"
msgstr ""

#: ../../user-api/intro.rst:4
msgid ""
"Backend.AI User API is for running instant compute sessions at scale in "
"clouds or on-premise clusters."
msgstr ""

#: ../../user-api/intro.rst:10
msgid "Code Execution Model"
msgstr ""

#: ../../user-api/intro.rst:12
msgid ""
"The core of the user API is the **execute** call which allows clients to "
"execute user-provided codes in isolated **compute sessions** (aka "
"**kernels**). Each session is managed by a **kernel runtime**, whose "
"implementation is language-specific. A runtime is often a containerized "
"daemon that interacts with the Backend.AI agent via our internal ZeroMQ "
"protocol. In some cases, kernel runtimes may be just proxies to other "
"code execution services instead of actual executor daemons."
msgstr ""

#: ../../user-api/intro.rst:17
msgid ""
"Inside each compute session, a client may perform multiple **runs**. Each"
" run is for executing different code snippets (**the query mode**) or "
"different sets of source files (**the batch mode**). The client often has"
" to call the **execute** API *multiple times* to finish a single run. It "
"is completely legal to mix query-mode runs and batch-mode runs inside the"
" same session, given that the kernel runtime supports both modes."
msgstr ""

#: ../../user-api/intro.rst:22
msgid ""
"To distinguish different runs which may be overlapped, the client must "
"provide the same **run ID** to all **execute** calls during a single run."
" The run ID should be unique for each run and can be an arbitrary random "
"string. If the run ID is not provided by the client at the first execute "
"call of a run, the API server will assign a random one and inform it to "
"the client via the first response. Normally, if two or more runs are "
"overlapped, they are processed in a FIFO order using an internal queue. "
"But they may be processed in parallel if the kernel runtime supports "
"parallel processing. Note that the API server may raise a timeout error "
"and cancel the run if the waiting time exceeds a certain limit."
msgstr ""

#: ../../user-api/intro.rst:29
msgid ""
"In the query mode, usually the runtime context (e.g., global variables) "
"is preserved for next subsequent runs, but this is not guaranteed by the "
"API itself---it's up to the kernel runtime implementation."
msgstr ""

#: ../../user-api/intro.rst:34
msgid "The state diagram of a “run” with the **execute** API."
msgstr ""

#: ../../user-api/intro.rst:36
msgid ""
"The **execute** API accepts 4 arguments: ``mode``, ``runId``, ``code``, "
"and ``options`` (``opts``). It returns an :ref:`execution-result-object` "
"encoded as JSON."
msgstr ""

#: ../../user-api/intro.rst:39
msgid ""
"Depending on the value of ``status`` field in the returned :ref"
":`execution-result-object`, the client must perform another subsequent "
"**execute** call with appropriate arguments or stop. :numref:`run-state-"
"diagram` shows all possible states and transitions between them via the "
"``status`` field value."
msgstr ""

#: ../../user-api/intro.rst:43
msgid "If ``status`` is ``\"finished\"``, the client should stop."
msgstr ""

#: ../../user-api/intro.rst:45
msgid ""
"If ``status`` is ``\"continued\"``, the client should make another "
"**execute** API call with the ``code`` field set to an empty string and "
"the ``mode`` field set to ``\"continue\"``. Continuation happens when the"
" user code runs longer than a few seconds to allow the client to show its"
" progress, or when it requires extra step to finish the run cycle."
msgstr ""

#: ../../user-api/intro.rst:48
msgid ""
"If ``status`` is ``\"clean-finished\"`` or ``\"build-finished\"`` (this "
"happens at the batch-mode only), the client should make the same "
"continuation call. Since cleanup is performed before every build, the "
"client will always receive ``\"build-finished\"`` after ``\"clean-"
"finished\"`` status. All outputs prior to ``\"build-finished\"`` status "
"return are from the build program and all future outputs are from the "
"executed program built. Note that even when the ``exitCode`` value is "
"non-zero (failed), the client must continue to complete the run cycle."
msgstr ""

#: ../../user-api/intro.rst:53
msgid ""
"If ``status`` is ``\"waiting-input\"``, you should make another "
"**execute** API call with the ``code`` field set to the user-input text "
"and the ``mode`` field set to ``\"input\"``. This happens when the user "
"code calls interactive ``input()`` functions. Until you send the user "
"input, the current run is blocked. You may use modal dialogs or other "
"input forms (e.g., HTML input) to retrieve user inputs. When the server "
"receives the user input, the kernel's ``input()`` returns the given "
"value. Note that each kernel runtime may provide different ways to "
"trigger this interactive input cycle or may not provide at all."
msgstr ""

#: ../../user-api/intro.rst:60
msgid ""
"When each call returns, the ``console`` field in the :ref:`execution-"
"result-object` have the console logs captured since the last previous "
"call. Check out the following section for details."
msgstr ""

#: ../../user-api/intro.rst:67
msgid "Handling Console Output"
msgstr ""

#: ../../user-api/intro.rst:69
msgid ""
"The console output consists of a list of tuple pairs of item type and "
"item data. The item type is one of ``\"stdout\"``, ``\"stderr\"``, "
"``\"media\"``, ``\"html\"``, or ``\"log\"``."
msgstr ""

#: ../../user-api/intro.rst:72
msgid ""
"When the item type is ``\"stdout\"`` or ``\"stderr\"``, the item data is "
"the standard I/O stream outputs as (non-escaped) UTF-8 string. The total "
"length of either streams is limited to 524,288 Unicode characters per "
"each **execute** API call; all excessive outputs are truncated. The "
"stderr often includes language-specific tracebacks of (unhandled) "
"exceptions or errors occurred in the user code. If the user code "
"generates a mixture of stdout and stderr, the print ordering is preserved"
" and each contiguous block of stdout/stderr becomes a separate item in "
"the console output list so that the client user can reconstruct the same "
"console output by sequentially rendering the items."
msgstr ""

#: ../../user-api/intro.rst:79
msgid ""
"The text in the stdout/stderr item may contain arbitrary terminal control"
" sequences such as ANSI color codes and cursor/line manipulations. It is "
"the user's job to strip out them or implement some sort of terminal "
"emulation."
msgstr ""

#: ../../user-api/intro.rst:84
msgid ""
"Since the console texts are *not* escaped, the client user should take "
"care of rendering and escaping depending on the UI implementation. For "
"example, use ``<pre>`` element, replace newlines with ``<br>``, or apply "
"``white-space: pre`` CSS style when rendering as HTML. An easy way to do "
"escape the text safely is to use ``insertAdjacentText()`` DOM API."
msgstr ""

#: ../../user-api/intro.rst:88
msgid ""
"When the item type is ``\"media\"``, the item data is a pair of the MIME "
"type and the content data. If the MIME type is text-based (e.g., "
"``\"text/plain\"``) or XML-based (e.g., ``\"image/svg+xml\"``), the "
"content is just a string that represent the content. Otherwise, the data "
"is encoded as a data URI format (RFC 2397). You may use `backend.ai-media"
" library <https://github.com/lablup/backend.ai-media>`_ to handle this "
"field in Javascript on web-browsers."
msgstr ""

#: ../../user-api/intro.rst:93
msgid ""
"When the item type is ``\"html\"``, the item data is a partial HTML "
"document string, such as a table to show tabular data. If you are "
"implementing a web-based front-end, you may use it directly to the "
"standard DOM API, for instance, ``consoleElem.insertAdjacentHTML(value, "
"\"beforeend\")``."
msgstr ""

#: ../../user-api/intro.rst:96
msgid ""
"When the item type is ``\"log\"``, the item data is a 4-tuple of the log "
"level, the timestamp in the ISO 8601 format, the logger name and the log "
"message string. The log level may be one of ``\"debug\"``, ``\"info\"``, "
"``\"warning\"``, ``\"error\"``, or ``\"fatal\"``. You may use different "
"colors/formatting by the log level when printing the log message. Not "
"every kernel runtime supports this rich logging facility."
msgstr ""

#: ../../user-api/resource-presets.rst:2
msgid "Resource Presets"
msgstr ""

#: ../../user-api/resource-presets.rst:4
msgid ""
"Resource presets provide a simple storage for pre-configured resource "
"slots and a dynamic checker for allocatability of given presets before "
"actually calling the kernel creation API."
msgstr ""

#: ../../user-api/resource-presets.rst:8
msgid ""
"To add/modify/delete resource presets, you need to use the admin GraphQL "
"API."
msgstr ""

#: ../../user-api/resource-presets.rst:14
msgid "Listing Resource Presets"
msgstr ""

#: ../../user-api/resource-presets.rst:16
msgid "Returns the list of admin-configured resource presets."
msgstr ""

#: ../../user-api/resource-presets.rst:18
msgid "URI: ``/resource/presets``"
msgstr ""

#: ../../user-api/resource-presets.rst:24
#: ../../user-api/resource-presets.rst:64 ../../user-api/vfolders.rst:37
#: ../../user-api/vfolders.rst:85
msgid "None."
msgstr ""

#: ../../user-api/resource-presets.rst:36
#: ../../user-api/resource-presets.rst:76
msgid "The preset list is returned."
msgstr ""

#: ../../user-api/resource-presets.rst:45
#: ../../user-api/resource-presets.rst:103
msgid "``presets``"
msgstr ""

#: ../../user-api/resource-presets.rst:46
#: ../../user-api/resource-presets.rst:104 ../../user-api/sessions.rst:163
#: ../../user-api/vfolders.rst:59 ../../user-api/vfolders.rst:349
#: ../../user-api/vfolders.rst:642
msgid "``list[object]``"
msgstr ""

#: ../../user-api/resource-presets.rst:47
msgid "The list of :ref:`resource-preset-object`"
msgstr ""

#: ../../user-api/resource-presets.rst:51
msgid "Checking Allocatability of Resource Presets"
msgstr ""

#: ../../user-api/resource-presets.rst:53
msgid ""
"Returns current keypair and scaling-group's resource limits in addition "
"to the list of admin-configured resource presets. It also checks the "
"allocatability of the resource presets and adds ``allocatable`` boolean "
"field to each preset item."
msgstr ""

#: ../../user-api/resource-presets.rst:58
msgid "URI: ``/resource/check-presets``"
msgstr ""

#: ../../user-api/resource-presets.rst:77
msgid "401 Unauthorized"
msgstr ""

#: ../../user-api/resource-presets.rst:78
msgid "The client is not authorized."
msgstr ""

#: ../../user-api/resource-presets.rst:87
msgid "``keypair_limits``"
msgstr ""

#: ../../user-api/resource-presets.rst:88
#: ../../user-api/resource-presets.rst:92
#: ../../user-api/resource-presets.rst:95
#: ../../user-api/resource-presets.rst:99
msgid ":ref:`resource-slot-object`"
msgstr ""

#: ../../user-api/resource-presets.rst:89
msgid ""
"The maximum amount of total resource slots allowed for the current access"
" key. It may contain infinity values as the string \"Infinity\"."
msgstr ""

#: ../../user-api/resource-presets.rst:91
msgid "``keypair_using``"
msgstr ""

#: ../../user-api/resource-presets.rst:93
msgid "The amount of total resource slots used by the current access key."
msgstr ""

#: ../../user-api/resource-presets.rst:94
msgid "``keypair_remaining``"
msgstr ""

#: ../../user-api/resource-presets.rst:96
msgid ""
"The amount of total resource slots remaining for the current access key. "
"It may contain infinity values as the string \"Infinity\"."
msgstr ""

#: ../../user-api/resource-presets.rst:98
msgid "``scaling_group_remaining``"
msgstr ""

#: ../../user-api/resource-presets.rst:100
msgid ""
"The amount of total resource slots remaining for the current scaling "
"group. It may contain infinity values as the string \"Infinity\" if the "
"server is configured for auto-scaling."
msgstr ""

#: ../../user-api/resource-presets.rst:105
msgid ""
"The list of :ref:`resource-preset-object`, but with an extra boolean "
"field ``allocatable`` which indicates if the given resource slot is "
"actually allocatable considering the keypair's resrouce limits and the "
"scaling group's current usage."
msgstr ""

#: ../../user-api/service-ports.rst:2
msgid "Service Ports (aka Service Proxies)"
msgstr ""

#: ../../user-api/service-ports.rst:4
msgid ""
"The service ports API provides WebSocket-based authenticated and "
"encrypted tunnels to network-facing services (\"container services\") "
"provided by the kernel container. The main advantage of this feature is "
"that all application-specific network traffic are wrapped as a standard "
"WebSocket API (no need to open extra ports of the manager). It also hides"
" the container from the client and the client from the container, "
"offerring an extra level of security."
msgstr ""

#: ../../user-api/service-ports.rst:14
msgid "The diagram showing how tunneling of TCP connections via WebSockets works."
msgstr ""

#: ../../user-api/service-ports.rst:16
msgid ""
"As :numref:`service-port-diagram` shows, all TCP traffic to a container "
"service could be sent to a WebSocket connection to the following API "
"endpoints.  A single WebSocket connection corresponds to a single TCP "
"connection to the service, and there may be multiple concurrent WebSocket"
" connections to represent multiple TCP connections to the service.  It is"
" the client's responsibility to accept arbitrary TCP connections from "
"users (e.g., web browsers) with proper authorization for multi-user "
"setups and wrap those as WebSocket connections to the following APIs."
msgstr ""

#: ../../user-api/service-ports.rst:25
msgid ""
"When the first connection is initiated, the Backend.AI Agent running the "
"designated kernel container signals the kernel runner daemon in the "
"container to start the designated service.  It shortly waits for the in-"
"container port opening and then delivers the first packet to the service."
"  After initialization, all WebSocket payloads are delivered back and "
"forth just like normal TCP packets. Note that the WebSocket message type "
"must be ``BINARY``."
msgstr ""

#: ../../user-api/service-ports.rst:32
msgid ""
"The container service will see the packets from the manager and it never "
"knows the real origin of packets unless the service-level protocol "
"enforces to state such client-side information.  Likewise, the client "
"never knows the container's IP address (though the port numbers are "
"included in :ref:`service port objects <service-port-object>` returned by"
" :ref:`the session creation API <create-session-api>`)."
msgstr ""

#: ../../user-api/service-ports.rst:39
msgid "Currently non-TCP (e.g., UDP) services are not supported."
msgstr ""

#: ../../user-api/service-ports.rst:43
msgid "Service Proxy (HTTP)"
msgstr ""

#: ../../user-api/service-ports.rst:45
msgid "URI: ``/stream/kernel/:id/httpproxy?app=:service``"
msgstr ""

#: ../../user-api/service-ports.rst:48
msgid ""
"The service proxy API allows clients to directly connect to service "
"daemons running *inside* compute sessions, such as Jupyter and "
"TensorBoard."
msgstr ""

#: ../../user-api/service-ports.rst:76
msgid "Service Proxy (TCP)"
msgstr ""

#: ../../user-api/service-ports.rst:78
msgid "URI: ``/stream/kernel/:id/tcpproxy?app=:service``"
msgstr ""

#: ../../user-api/service-ports.rst:81
msgid ""
"This is the TCP version of service proxy, so that client users can "
"connect to native services running inside compute sessions, such as SSH."
msgstr ""

#: ../../user-api/sessions.rst:2
msgid "Session Management"
msgstr ""

#: ../../user-api/sessions.rst:4
msgid "Here are the API calls to create and manage compute sessions."
msgstr ""

#: ../../user-api/sessions.rst:9
msgid "Creating Session"
msgstr ""

#: ../../user-api/sessions.rst:11
msgid "URI: ``/session`` (``/session/create`` also works for legacy)"
msgstr ""

#: ../../user-api/sessions.rst:14
msgid ""
"Creates a new session or returns an existing session, depending on the "
"parameters."
msgstr ""

#: ../../user-api/sessions.rst:27
msgid "``image``"
msgstr ""

#: ../../user-api/sessions.rst:29
msgid ""
"The kernel runtime type in the form of the Docker image name and tag. For"
" legacy, the API also recognizes the ``lang`` field when ``image`` is not"
" present."
msgstr ""

#: ../../user-api/sessions.rst:34
msgid "``clientSessionToken``"
msgstr ""

#: ../../user-api/sessions.rst:36
msgid ""
"A client-provided session token, which must be unique among the currently"
" non-terminated sessions owned by the requesting access key. Clients may "
"reuse the token if the previous session with the same token has been "
"terminated."
msgstr ""

#: ../../user-api/sessions.rst:41
msgid ""
"It may contain ASCII alphabets, numbers, and hyphens in the middle. The "
"length must be between 4 to 64 characters inclusively. It is useful for "
"aliasing the session with a human-friendly name."
msgstr ""

#: ../../user-api/sessions.rst:45
msgid "``enqueueOnly``"
msgstr ""

#: ../../user-api/sessions.rst:46 ../../user-api/sessions.rst:62
#: ../../user-api/sessions.rst:176 ../../user-api/vfolders.rst:589
#: ../../user-api/vfolders.rst:726
msgid "``bool``"
msgstr ""

#: ../../user-api/sessions.rst:47
msgid ""
"*(optional)* If set true, the API returns immediately after queueing the "
"session creation request to the scheduler. Otherwise, the manager will "
"wait until the session gets started actually. (default: ``false``)"
msgstr ""

#: ../../user-api/sessions.rst:53
msgid "``maxWaitSeconds``"
msgstr ""

#: ../../user-api/sessions.rst:55
msgid ""
"*(optional)* Set the maximum duration to wait until the session starts "
"after queued, in seconds.  If zero, the manager will wait indefinitely. "
"(default: ``0``)"
msgstr ""

#: ../../user-api/sessions.rst:61
msgid "``reuseIfExists``"
msgstr ""

#: ../../user-api/sessions.rst:63
msgid ""
"*(optional)* If set true, the API returns *without* creating a new "
"session if a session with the same ID and the same image already exists "
"and not terminated. In this case ``config`` options are *ignored*. If set"
" false but a session with the same ID and image exists, the manager "
"returns an error: \"session already exists\". (default: ``true``)"
msgstr ""

#: ../../user-api/sessions.rst:74
msgid ""
"*(optional)* The name of a user group (aka \"project\") to launch the "
"session within.  (default: ``\"default\"``)"
msgstr ""

#: ../../user-api/sessions.rst:78
msgid "``domain``"
msgstr ""

#: ../../user-api/sessions.rst:80
msgid ""
"*(optional)* The name of a domain to launch the session within  (default:"
" ``\"default\"``)"
msgstr ""

#: ../../user-api/sessions.rst:84
msgid "``config``"
msgstr ""

#: ../../user-api/sessions.rst:86
msgid ""
"*(optional)* A :ref:`creation-config-object` to specify kernel "
"configuration including resource requirements. If not given, the kernel "
"is created with the minimum required resource slots defined by the target"
" image."
msgstr ""

#: ../../user-api/sessions.rst:91
msgid "``tag``"
msgstr ""

#: ../../user-api/sessions.rst:93
msgid ""
"*(optional)* A per-session, user-provided tag for administrators to keep "
"track of additional information of each session, such as which sessions "
"are from which users."
msgstr ""

#: ../../user-api/sessions.rst:134
msgid "The session is already running and you are okay to reuse it."
msgstr ""

#: ../../user-api/sessions.rst:135 ../../user-api/vfolders.rst:167
#: ../../user-api/vfolders.rst:392 ../../user-api/vfolders.rst:441
msgid "201 Created"
msgstr ""

#: ../../user-api/sessions.rst:136
#, fuzzy
msgid "The session is successfully created."
msgstr "세션이 종료되었습니다."

#: ../../user-api/sessions.rst:137
msgid "401 Invalid API parameters"
msgstr ""

#: ../../user-api/sessions.rst:138
msgid "There are invalid or malformed values in the API parameters."
msgstr ""

#: ../../user-api/sessions.rst:139 ../../user-api/vfolders.rst:172
msgid "406 Not acceptable"
msgstr ""

#: ../../user-api/sessions.rst:140
msgid "The requested resource limits exceed the server's own limits."
msgstr ""

#: ../../user-api/sessions.rst:149
msgid "``sessId``"
msgstr ""

#: ../../user-api/sessions.rst:151
msgid ""
"The session ID used for later API calls, which is same to the value of "
"``clientSessionToken``. This will be random-generated by the server if "
"``clientSessionToken`` is not provided."
msgstr ""

#: ../../user-api/sessions.rst:153
msgid "``status``"
msgstr ""

#: ../../user-api/sessions.rst:155
msgid ""
"The status of the created kernel. This is always ``\"PENDING\"`` if "
"``enqueueOnly`` is set true. In other cases, it may be either "
"``\"RUNNING\"`` (normal case), ``\"ERROR\"``, or even ``\"TERMINATED\"`` "
"depending on what happens during session startup."
msgstr ""

#: ../../user-api/sessions.rst:162
msgid "``servicePorts``"
msgstr ""

#: ../../user-api/sessions.rst:164
msgid ""
"The list of :ref:`service-port-object`. This field becomes an empty list "
"if ``enqueueOnly`` is set true, because the final service ports are "
"determined when the session becomes ready after scheduling."
msgstr ""

#: ../../user-api/sessions.rst:170
msgid ""
"In most cases the service ports are same to what specified in the image "
"metadata, but the agent may add shared services for all sessions."
msgstr ""

#: ../../user-api/sessions.rst:175
msgid "``created``"
msgstr ""

#: ../../user-api/sessions.rst:177
#, fuzzy
msgid "True if the session is freshly created."
msgstr "세션이 종료되었습니다."

#: ../../user-api/sessions.rst:196
msgid "Getting Session Information"
msgstr ""

#: ../../user-api/sessions.rst:201
msgid ""
"Retrieves information about a session. For performance reasons, the "
"returned information may not be real-time; usually they are updated every"
" a few seconds in the server-side."
msgstr ""

#: ../../user-api/sessions.rst:229 ../../user-api/vfolders.rst:239
msgid "The information is successfully returned."
msgstr ""

#: ../../user-api/sessions.rst:231 ../../user-api/sessions.rst:291
#: ../../user-api/sessions.rst:341
#, fuzzy
msgid "There is no such session."
msgstr "소스 세션 아이디"

#: ../../user-api/sessions.rst:237 ../../user-api/sessions.rst:297
msgid "Key"
msgstr ""

#: ../../user-api/sessions.rst:240
msgid "``lang``"
msgstr ""

#: ../../user-api/sessions.rst:242
msgid "The kernel's programming language"
msgstr ""

#: ../../user-api/sessions.rst:243
msgid "``age``"
msgstr ""

#: ../../user-api/sessions.rst:244 ../../user-api/sessions.rst:253
msgid "``int`` (msec)"
msgstr ""

#: ../../user-api/sessions.rst:245
msgid "The time elapsed since the kernel has started."
msgstr ""

#: ../../user-api/sessions.rst:246
msgid "``memoryLimit``"
msgstr ""

#: ../../user-api/sessions.rst:247
msgid "``int`` (KiB)"
msgstr ""

#: ../../user-api/sessions.rst:248
msgid "The memory limit of the kernel in KiB."
msgstr ""

#: ../../user-api/sessions.rst:249
msgid "``numQueriesExecuted``"
msgstr ""

#: ../../user-api/sessions.rst:251
msgid "The number of times the kernel has been accessed."
msgstr ""

#: ../../user-api/sessions.rst:252
msgid "``cpuCreditUsed``"
msgstr ""

#: ../../user-api/sessions.rst:254
msgid "The total time the kernel was running."
msgstr ""

#: ../../user-api/sessions.rst:258
msgid "Destroying Session"
msgstr ""

#: ../../user-api/sessions.rst:261 ../../user-api/vfolders.rst:260
#: ../../user-api/vfolders.rst:570 ../../user-api/vfolders.rst:763
msgid "Method: ``DELETE``"
msgstr ""

#: ../../user-api/sessions.rst:263
msgid "Terminates a session."
msgstr ""

#: ../../user-api/sessions.rst:289
msgid "The session is successfully destroyed."
msgstr ""

#: ../../user-api/sessions.rst:300
msgid "``stats``"
msgstr ""

#: ../../user-api/sessions.rst:302
msgid "The :ref:`container-stats-object` of the kernel when deleted."
msgstr ""

#: ../../user-api/sessions.rst:306
msgid "Restarting Session"
msgstr ""

#: ../../user-api/sessions.rst:309
msgid "Method: ``PATCH``"
msgstr ""

#: ../../user-api/sessions.rst:311
msgid ""
"Restarts a session. The idle time of the session will be reset, but other"
" properties such as the age and CPU credit will continue to accumulate. "
"All global states such as global variables and modules imports are also "
"reset."
msgstr ""

#: ../../user-api/sessions.rst:339
msgid "The session is successfully restarted."
msgstr ""

#: ../../user-api/vfolders.rst:2
msgid "Virtual Folders"
msgstr ""

#: ../../user-api/vfolders.rst:4
msgid ""
"Virtual folders provide access to shared, persistent, and reused files "
"across different sessions."
msgstr ""

#: ../../user-api/vfolders.rst:7
msgid ""
"You can mount virtual folders when creating new sessions, and use them "
"like a plain directory on the local filesystem. Of course, reads/writes "
"to virtual folder contents may have degraded performance compared to the "
"main scratch directory (usually ``/home/work`` in most kernels) as "
"internally it uses a networked file system."
msgstr ""

#: ../../user-api/vfolders.rst:13
msgid ""
"Also, you might share your virtual folders with other users by inviting "
"them and granting them proper permission. Currently, there are three "
"levels of permissions: read-only, read-write, read-write-delete. They are"
" represented by short strings, ``'ro'``, ``'rw'``, ``'rd'``, "
"respectively. The owner of a virtual folder have read-write-delete "
"permission for the folder."
msgstr ""

#: ../../user-api/vfolders.rst:21
msgid ""
"Currently the total size of a virtual folder is limited to 1 GiB and the "
"number of files is limited to 1,000 files during public beta, but these "
"limits are subject to change in the future."
msgstr ""

#: ../../user-api/vfolders.rst:27
msgid "Listing Virtual Folders"
msgstr ""

#: ../../user-api/vfolders.rst:29
msgid "Returns the list of virtual folders created by the current keypair."
msgstr ""

#: ../../user-api/vfolders.rst:31 ../../user-api/vfolders.rst:125
msgid "URI: ``/folders``"
msgstr ""

#: ../../user-api/vfolders.rst:58 ../../user-api/vfolders.rst:251
msgid "(root)"
msgstr ""

#: ../../user-api/vfolders.rst:60
msgid "A list of :ref:`vfolder-list-item-object`."
msgstr ""

#: ../../user-api/vfolders.rst:73
msgid "Listing Virtual Folder Hosts"
msgstr ""

#: ../../user-api/vfolders.rst:75
msgid ""
"Returns the list of available host names where the current keypair can "
"create new virtual folders."
msgstr ""

#: ../../user-api/vfolders.rst:79
msgid "URI: ``/folders/_/hosts``"
msgstr ""

#: ../../user-api/vfolders.rst:106
msgid "``default``"
msgstr ""

#: ../../user-api/vfolders.rst:108
msgid "The default virtual folder host."
msgstr ""

#: ../../user-api/vfolders.rst:109
msgid "``allowed``"
msgstr ""

#: ../../user-api/vfolders.rst:111
msgid "The list of available virtual folder hosts."
msgstr ""

#: ../../user-api/vfolders.rst:123
msgid "Creating a Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:128
msgid "Creates a virtual folder associated with the current API key."
msgstr ""

#: ../../user-api/vfolders.rst:141 ../../user-api/vfolders.rst:186
#: ../../user-api/vfolders.rst:225 ../../user-api/vfolders.rst:283
msgid "``name``"
msgstr ""

#: ../../user-api/vfolders.rst:143 ../../user-api/vfolders.rst:227
#: ../../user-api/vfolders.rst:284 ../../user-api/vfolders.rst:322
#: ../../user-api/vfolders.rst:377 ../../user-api/vfolders.rst:427
#: ../../user-api/vfolders.rst:474 ../../user-api/vfolders.rst:530
#: ../../user-api/vfolders.rst:584 ../../user-api/vfolders.rst:668
msgid "The human-readable name of the virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:144 ../../user-api/vfolders.rst:189
msgid "``host``"
msgstr ""

#: ../../user-api/vfolders.rst:146
msgid "(optional) The name of the virtual folder host."
msgstr ""

#: ../../user-api/vfolders.rst:168
msgid "The kernel is successfully created."
msgstr ""

#: ../../user-api/vfolders.rst:170
msgid "The name is malformed or duplicate with your existing virtual folders."
msgstr ""

#: ../../user-api/vfolders.rst:173
msgid ""
"You have exceeded internal limits of virtual folders. (e.g., the maximum "
"number of folders you can have.)"
msgstr ""

#: ../../user-api/vfolders.rst:183
msgid "``id``"
msgstr ""

#: ../../user-api/vfolders.rst:185
msgid "The unique folder ID used for later API calls."
msgstr ""

#: ../../user-api/vfolders.rst:188
msgid "The human-readable name of the created virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:191
msgid "The name of the virtual folder host where the new folder is created."
msgstr ""

#: ../../user-api/vfolders.rst:206
msgid "Getting Virtual Folder Information"
msgstr ""

#: ../../user-api/vfolders.rst:208 ../../user-api/vfolders.rst:259
msgid "URI: ``/folders/:name``"
msgstr ""

#: ../../user-api/vfolders.rst:211
msgid ""
"Retrieves information about a virtual folder. For performance reasons, "
"the returned information may not be real-time; usually they are updated "
"every a few seconds in the server-side."
msgstr ""

#: ../../user-api/vfolders.rst:241
msgid ""
"There is no such folder or you may not have proper permission to access "
"the folder."
msgstr ""

#: ../../user-api/vfolders.rst:253
msgid ":ref:`vfolder-item-object`."
msgstr ""

#: ../../user-api/vfolders.rst:257
msgid "Deleting Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:262
msgid ""
"This immediately deletes all contents of the given virtual folder and "
"makes the folder unavailable for future mounts."
msgstr ""

#: ../../user-api/vfolders.rst:267
msgid ""
"If there are running kernels that have mounted the deleted virtual "
"folder, those kernels are likely to break!"
msgstr ""

#: ../../user-api/vfolders.rst:272
msgid "There is NO way to get back the contents once this API is invoked."
msgstr ""

#: ../../user-api/vfolders.rst:296
msgid "The folder is successfully destroyed."
msgstr ""

#: ../../user-api/vfolders.rst:298
msgid ""
"There is no such folder or you may not have proper permission to delete "
"the folder."
msgstr ""

#: ../../user-api/vfolders.rst:303
msgid "Listing Files in Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:305
msgid ""
"Returns the list of files in a virtual folder associated with current "
"keypair."
msgstr ""

#: ../../user-api/vfolders.rst:307
msgid "URI: ``/folders/:name/files``"
msgstr ""

#: ../../user-api/vfolders.rst:320 ../../user-api/vfolders.rst:375
#: ../../user-api/vfolders.rst:425 ../../user-api/vfolders.rst:472
#: ../../user-api/vfolders.rst:528 ../../user-api/vfolders.rst:582
#: ../../user-api/vfolders.rst:666
msgid "``:name``"
msgstr ""

#: ../../user-api/vfolders.rst:325
msgid "Path inside the virtual folder (default: root)."
msgstr ""

#: ../../user-api/vfolders.rst:338
msgid ""
"There is no such path or you may not have proper permission to access the"
" folder."
msgstr ""

#: ../../user-api/vfolders.rst:350
msgid "List of :ref:`vfolder-file-object`"
msgstr ""

#: ../../user-api/vfolders.rst:354
msgid "Uploading Multiple Files to Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:356
msgid "Upload local files to a virtual folder associated with current keypair."
msgstr ""

#: ../../user-api/vfolders.rst:358
msgid "URI: ``/folders/:name/upload``"
msgstr ""

#: ../../user-api/vfolders.rst:362
msgid ""
"If a file with the same name already exists in the virtual folder, it "
"will be overwritten without warning."
msgstr ""

#: ../../user-api/vfolders.rst:378 ../../user-api/vfolders.rst:500
#: ../../user-api/vfolders.rst:556
msgid "(body)"
msgstr ""

#: ../../user-api/vfolders.rst:379 ../../user-api/vfolders.rst:557
msgid "``multipart``"
msgstr ""

#: ../../user-api/vfolders.rst:380
msgid ""
"A multi-part encoded file data which is composed of multiple occurrences "
"of ``src`` field.  Each part must contain a valid filename and the "
"content type is always assumed as ``application/octet-stream``."
msgstr ""

#: ../../user-api/vfolders.rst:395
msgid ""
"There already exists a file with duplicated name that cannot be "
"overwritten in the virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:398 ../../user-api/vfolders.rst:446
msgid ""
"There is no such folder or you may not have proper permission to write "
"into folder."
msgstr ""

#: ../../user-api/vfolders.rst:403
msgid "Creating New Directory in Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:405
msgid ""
"Create a new directory in the virtual folder associated with current "
"keypair. this API recursively creates parent directories if they does not"
" exist."
msgstr ""

#: ../../user-api/vfolders.rst:408
msgid "URI: ``/folders/:name/mkdir``"
msgstr ""

#: ../../user-api/vfolders.rst:412
msgid ""
"If a directory with the same name already exists in the virtual folder, "
"it will be overwritten without warning."
msgstr ""

#: ../../user-api/vfolders.rst:430
msgid "The relative path of a new folder to create inside the virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:444
msgid "There already exists a file, not a directory, with duplicated name."
msgstr ""

#: ../../user-api/vfolders.rst:451
msgid "Downloading Single File from Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:453
msgid ""
"Download a single file from a virtual folder associated with the current "
"keypair. This API does not perform any encoding or compression but just "
"outputs the raw file content as the response body, for simpler client-"
"side implementation."
msgstr ""

#: ../../user-api/vfolders.rst:459
msgid "URI: ``/folders/:name/download_single``"
msgstr ""

#: ../../user-api/vfolders.rst:475
msgid "``file``"
msgstr ""

#: ../../user-api/vfolders.rst:477
msgid "A file path inside the virtual folder to download."
msgstr ""

#: ../../user-api/vfolders.rst:490 ../../user-api/vfolders.rst:546
msgid "File not found or you may not have proper permission to access the folder."
msgstr ""

#: ../../user-api/vfolders.rst:501
msgid "``bytes``"
msgstr ""

#: ../../user-api/vfolders.rst:502
msgid "The content of file."
msgstr ""

#: ../../user-api/vfolders.rst:505
msgid "Downloading Multiple Files from Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:507
msgid "Download files from a virtual folder associated with the current keypair."
msgstr ""

#: ../../user-api/vfolders.rst:509
msgid ""
"The response contents are streamed as gzipped binaries (``Content-"
"Encoding: gzip``) in a multi-part message format. Clients may detect the "
"total download size using ``X-TOTAL-PAYLOADS-LENGTH`` (all upper case) "
"HTTP header of the response in prior to reading/parsing the response "
"body."
msgstr ""

#: ../../user-api/vfolders.rst:515
msgid "URI: ``/folders/:name/download``"
msgstr ""

#: ../../user-api/vfolders.rst:533
msgid "File paths inside the virtual folder to download."
msgstr ""

#: ../../user-api/vfolders.rst:558
msgid "The gzipped content of files in the mixed multipart format."
msgstr ""

#: ../../user-api/vfolders.rst:562
msgid "Deleting Files in Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:564
msgid "This deletes files inside a virtual folder."
msgstr ""

#: ../../user-api/vfolders.rst:567
msgid "There is NO way to get back the files once this API is invoked."
msgstr ""

#: ../../user-api/vfolders.rst:569
msgid "URI: ``/folders/:name/delete_files``"
msgstr ""

#: ../../user-api/vfolders.rst:587
msgid "File paths inside the virtual folder to delete."
msgstr ""

#: ../../user-api/vfolders.rst:588
msgid "``recursive``"
msgstr ""

#: ../../user-api/vfolders.rst:590
msgid "Recursive option to delete folders if set to True. The default is False."
msgstr ""

#: ../../user-api/vfolders.rst:603
msgid "You tried to delete a folder without setting recursive option as True."
msgstr ""

#: ../../user-api/vfolders.rst:605
msgid ""
"There is no such folder or you may not have proper permission to delete "
"the file in the folder."
msgstr ""

#: ../../user-api/vfolders.rst:610
msgid "Listing Invitations for Virtual Folder"
msgstr ""

#: ../../user-api/vfolders.rst:612
msgid "Returns the list of pending invitations that requested user received."
msgstr ""

#: ../../user-api/vfolders.rst:614
msgid "URI: ``/folders/invitations/list``"
msgstr ""

#: ../../user-api/vfolders.rst:620
msgid "This API does not need any parameter."
msgstr ""

#: ../../user-api/vfolders.rst:641
msgid "``invitations``"
msgstr ""

#: ../../user-api/vfolders.rst:643
msgid "A list of :ref:`vfolder-invitation-object`."
msgstr ""

#: ../../user-api/vfolders.rst:647
msgid "Creating an Invitation"
msgstr ""

#: ../../user-api/vfolders.rst:649
msgid ""
"Invite other users to share a virtual folder with proper permissions. If "
"a user is already invited, then this API does not create a new invitation"
" or update the permission of the existing invitation."
msgstr ""

#: ../../user-api/vfolders.rst:653
msgid "URI: ``/folders/:name/invite``"
msgstr ""

#: ../../user-api/vfolders.rst:669
msgid "``perm``"
msgstr ""

#: ../../user-api/vfolders.rst:671
msgid "The permission to grant to invitee."
msgstr ""

#: ../../user-api/vfolders.rst:672
msgid "``user_ids``"
msgstr ""

#: ../../user-api/vfolders.rst:673 ../../user-api/vfolders.rst:700
msgid "``list[slug]``"
msgstr ""

#: ../../user-api/vfolders.rst:674
msgid "A list of user IDs to invite."
msgstr ""

#: ../../user-api/vfolders.rst:688
msgid "No invitee is given."
msgstr ""

#: ../../user-api/vfolders.rst:690
msgid "There is no invitation."
msgstr ""

#: ../../user-api/vfolders.rst:699
msgid "``invited_ids``"
msgstr ""

#: ../../user-api/vfolders.rst:701
msgid "A list of invited user IDs."
msgstr ""

#: ../../user-api/vfolders.rst:705
msgid "Accepting an Invitation"
msgstr ""

#: ../../user-api/vfolders.rst:707
msgid ""
"Accept an invitation and receive permission to a virtual folder as in the"
" invitation."
msgstr ""

#: ../../user-api/vfolders.rst:709
msgid "URI: ``/folders/invitations/accept``"
msgstr ""

#: ../../user-api/vfolders.rst:722 ../../user-api/vfolders.rst:775
msgid "``inv_id``"
msgstr ""

#: ../../user-api/vfolders.rst:724 ../../user-api/vfolders.rst:777
msgid "The unique invitation ID."
msgstr ""

#: ../../user-api/vfolders.rst:725
msgid "``inv_ak``"
msgstr ""

#: ../../user-api/vfolders.rst:727
msgid "The access key of invitee."
msgstr ""

#: ../../user-api/vfolders.rst:741
msgid ""
"The name of the target virtual folder is duplicate with your existing "
"virtual folders."
msgstr ""

#: ../../user-api/vfolders.rst:744 ../../user-api/vfolders.rst:791
msgid "There is no such invitation."
msgstr ""

#: ../../user-api/vfolders.rst:753 ../../user-api/vfolders.rst:800
msgid "``msg``"
msgstr ""

#: ../../user-api/vfolders.rst:755
msgid "Detail message for the invitation acceptance."
msgstr ""

#: ../../user-api/vfolders.rst:758
msgid "Rejecting an Invitation"
msgstr ""

#: ../../user-api/vfolders.rst:760
msgid "Reject an invitation."
msgstr ""

#: ../../user-api/vfolders.rst:762
msgid "URI: ``/folders/invitations/delete``"
msgstr ""

#: ../../user-api/vfolders.rst:802
msgid "Detail message for the invitation deletion."
msgstr ""

#~ msgid "URI: ``/kernel/:id/upload``"
#~ msgstr ""

#~ msgid "URI: ``/kernel/:id/files``"
#~ msgstr ""

#~ msgid "URI: ``/kernel/:id/download``"
#~ msgstr ""

#~ msgid ""
#~ "Executes a snippet of user code "
#~ "using the specified session. Each "
#~ "execution request to a same session "
#~ "may have side-effects to subsequent "
#~ "executions. For instance, setting a "
#~ "global variable in a request and "
#~ "reading the variable in another request"
#~ " is completely legal. It is the "
#~ "job of the user (or the front-"
#~ "end) to gaurantee the correct execution"
#~ " order of multiple interdependent requests."
#~ " When the kernel session is "
#~ "terminated or restarted, all such "
#~ "volatile states vanish."
#~ msgstr ""

#~ msgid "Kernel Management"
#~ msgstr ""

#~ msgid "URI: ``/kernel`` (``/kernel/create`` also works for legacy)"
#~ msgstr ""

#~ msgid ""
#~ "*(optional)* If set true, the API "
#~ "returns *without* creating a new session"
#~ " if a session with the same ID"
#~ " and the same image already exists"
#~ " and not terminated. In this case "
#~ "``config`` options are *ignored*. If set"
#~ " false but a session with the "
#~ "same ID and image exists, the "
#~ "manager returns an error: \"kernel "
#~ "already exists\". (default: ``true``)"
#~ msgstr ""

#~ msgid "The kernel is already running and you are okay to reuse it."
#~ msgstr ""

#~ msgid "``kernelId``"
#~ msgstr ""

#~ msgid ""
#~ "In most cases the service ports "
#~ "are same to what specified in the"
#~ " image metadata, but the agent may"
#~ " add shared services for all kernels."
#~ msgstr ""

#~ msgid "True if the kernel is freshly created."
#~ msgstr ""

#~ msgid "Getting Kernel Information"
#~ msgstr ""

#~ msgid "There is no such kernel."
#~ msgstr ""

#~ msgid "The kernel is successfully destroyed."
#~ msgstr ""

#~ msgid ""
#~ "Restarts a session. The idle time "
#~ "of the kernel will be reset, but"
#~ " other properties such as the age "
#~ "and CPU credit will continue to "
#~ "accumulate. All global states such as"
#~ " global variables and modules imports "
#~ "are also reset."
#~ msgstr ""

#~ msgid "The kernel is successfully restarted."
#~ msgstr ""

