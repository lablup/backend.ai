# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2018, Lablup Inc.
# This file is distributed under the same license as the Backend.AI API
# Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Backend.AI API Documentation 1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-14 21:43+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../../dev/repl.rst:2
msgid "Adding New REPL Kernels"
msgstr "새 REPL 커널 추가"

#: ../../dev/repl.rst:5
msgid "Architecture Overview"
msgstr "아키텍처 개괄"

#: ../../dev/repl.rst:7
msgid ""
"Inside containers, each kernel is a simple daemon process that accepts "
"user code snippets and replies with its execution results via TCP-based "
"ZeroMQ connections. The rationale to use ZeroMQ is: 1) it is message-"
"based; we do not have to concern the message boundaries and encodings, 2)"
" it automatically reconnects when the connection is lost due to network "
"failures or packet losses, 3) it is one of the most universally supported"
" networking library in various programming languages."
msgstr ""
"컨테이너 내부에서 각 커널은 TCP 기반 ZeroMQ 연결을 통해 "
"사용자 코드 스니펫을 받아들이고 실행 결과를 회신하는 간단한 "
"데몬 프로세스입니다. ZeroMQ를 사용하는 근거는 1) 메시지 "
"기반으로 메시지 경계와 인코딩을 신경 쓸 필요가 없고, "
"2) 네트워크 장애나 패킷 손실로 연결이 끊기면 자동으로 "
"다시 연결되고, 3) 다양한 프로그래밍 언어에서 가장 보편적으로 "
"지원되는 네트워킹 라이브러리 중 하나이기 때문입니다."
#: ../../dev/repl.rst:13
msgid ""
"A kernel should offer the *query mode* and/or the *PTY mode*. The TCP "
"port 2001 is reserved for the query mode whereas 2002 and 2003 are "
"reserved for the PTY mode (stdin and stdout combined with stderr)."
msgstr ""
"커널은 *query 모드* 및/또는 *PTY 모드*를 제공해야 합니다. TCP 포트 "
"2001은 query모드로 예약된 반면 2002와 2003은 PTY 모드(stdin및 "
"stdout과 stderr가 결합된)로 예약됩니다."

#: ../../dev/repl.rst:17
msgid "Ingredients of Kernel Images"
msgstr ""

#: ../../dev/repl.rst:19
msgid "A kernel is a Docker image with the following format:"
msgstr "커널은 다음 포맷을 따르는 도커 이미지입니다."

#: ../../dev/repl.rst:21
msgid "``Dockerfile``"
msgstr ""

#: ../../dev/repl.rst:23
msgid ""
"``WORKDIR /home/work``: this path is used to mount an external directory "
"so that the agent can access files generated by user codes."
msgstr ""

#: ../../dev/repl.rst:25
msgid "``CMD`` must be set to the main program."
msgstr ""

#: ../../dev/repl.rst:27
msgid "Required Labels"
msgstr ""

#: ../../dev/repl.rst:29
msgid ""
"``ai.backend.maxcores``: *N* (the number of CPU cores recommended for "
"this kernel)"
msgstr ""

#: ../../dev/repl.rst:30
msgid ""
"``ai.backend.maxmem``: *M* (the memory size in a human-readable bytes "
"recommended for this kernel, ``128m`` (128 MBytes) for example)"
msgstr ""

#: ../../dev/repl.rst:31
msgid ""
"``ai.backend.timeout``: *T* (the maximum seconds allowed to execute a "
"single query)"
msgstr ""

#: ../../dev/repl.rst:32
msgid ""
"Above limits are used as default settings by Backend.AI Agent, but the "
"agents may enforce lower limits due to the service policy.  Backend.AI "
"Gateway may refer these information for load balancing and scheduling."
msgstr ""

#: ../../dev/repl.rst:33
msgid "``ai.backend.mode``: ``query``, ``pty``, or ``query+pty``"
msgstr ""

#: ../../dev/repl.rst:35
msgid "Optional Labels"
msgstr ""

#: ../../dev/repl.rst:37
msgid ""
"``ai.backend.envs.corecount``: a comma-separated string of environment "
"variable names which will be set to the number of assigned CPU cores by "
"the agent. (e.g., ``JULIA_CPU_CORES``, ``OPENBLAS_NUM_THREADS``)"
msgstr ""

#: ../../dev/repl.rst:38
msgid ""
"``ai.backend.nvidia.enabled``: ``yes`` or ``no`` (if yes, Backend.AI "
"Agent attaches an NVIDIA CUDA GPU device with a driver volume. You must "
"use `nvidia-docker images <https://github.com/NVIDIA/nvidia-docker>`_ as "
"base of your Dockerfile.)"
msgstr ""

#: ../../dev/repl.rst:39
msgid ""
"``ai.backend.extra_volumes``: a comma-separated string of extra volume "
"mounts (volume name and path inside container separated by a colon), such"
" as deep learning sample data sets (e.g., ``sample-"
"data:/home/work/samples,extra-data:/home/work/extra``). Note that we "
"allow only read-only mounts. The available list of extra volumes depends "
"on your Backend.AI Agent setup; there is no standard or predefined ones. "
"If you want to add a new one, use ``docker volume`` commands. When "
"designated volumes do not exist in the agent's host, the agent silently "
"skips mounting them."
msgstr ""

#: ../../dev/repl.rst:44
msgid ""
"``ai.backend.features``: a comma-separated string keywords indicating "
"available features of this kernel."
msgstr ""

#: ../../dev/repl.rst:50
msgid "Keyword"
msgstr ""

#: ../../dev/repl.rst:51
msgid "Feature"
msgstr ""

#: ../../dev/repl.rst:52
msgid "``media.images``"
msgstr ""

#: ../../dev/repl.rst:53
msgid "Generates images (PNG, JPG, and SVG) without uploading into AWS S3."
msgstr ""

#: ../../dev/repl.rst:54
msgid "``media.svgplot``"
msgstr ""

#: ../../dev/repl.rst:55
msgid "Generates plots in SVG."
msgstr ""

#: ../../dev/repl.rst:56
msgid "``media.drawing``"
msgstr ""

#: ../../dev/repl.rst:57
msgid ""
"Generates animated vector graphics which can be rendered by `sorna-media "
"<https://github.com/lablup/sorna-media>`_ Javascript library"
msgstr ""

#: ../../dev/repl.rst:58
msgid "``media.audio``"
msgstr ""

#: ../../dev/repl.rst:59
msgid "Generates audio signal streams. (not implemented)"
msgstr ""

#: ../../dev/repl.rst:61
msgid ""
"The main program that implements the query mode and/or the PTY mode (see "
"below)."
msgstr ""

#: ../../dev/repl.rst:63
msgid ""
"We strongly recommend to create a normal user instead of using root for "
"the main program."
msgstr ""

#: ../../dev/repl.rst:64
msgid ""
"The main program should be wrapped with `jail "
"<https://github.com/lablup/backend.ai-"
"kernels/blob/master/base/Dockerfile.jail>`_, like:"
msgstr ""

#: ../../dev/repl.rst:71
msgid ""
"The first argument to jail is the policy name and the second and laters "
"are the absolute path of the main program with its arguments. To "
"customize the jail policy, :ref:`see below <custom-jail-policy>`."
msgstr ""

#: ../../dev/repl.rst:74
msgid "``jail`` and ``intra-jail`` must be copied into the kernel image."
msgstr ""

#: ../../dev/repl.rst:76
msgid ""
"Other auxilliary files used in Dockerfile or the main program. (e.g., "
"Python and package installation scripts)"
msgstr ""

#: ../../dev/repl.rst:80
msgid "Writing Query Mode Kernels"
msgstr ""

#: ../../dev/repl.rst:82
msgid ""
"Most kernels fall into this category. You just write a simple blocking "
"loop that receives a input code message and send a output result message "
"via a ZeroMQ REP socket listening on port 2001. All complicated stuffs "
"such as multiplexing multiple user requests and container management is "
"done by Backend.AI Agent."
msgstr ""

#: ../../dev/repl.rst:86
msgid ""
"The input is a ZeroMQ's multipart message with two payloads. The first "
"payload should contain a unique identifier for the code snippet (usually "
"a hash of it), but currently it is ignored (reserved for future caching "
"implementations). The second payload should contain a UTF-8 encoded "
"source code string."
msgstr ""

#: ../../dev/repl.rst:90
msgid ""
"The reply is a ZeroMQ's multipart message with a single payload, "
"containing a UTF-8 encoded string of the following JSON object:"
msgstr ""

#: ../../dev/repl.rst:111
msgid ""
"Each item in ``exceptions`` is an array composed of four items: exception"
" name, exception arguments (optional), a boolean indicating if the "
"exception is raised outside the user code (mostly false), and a traceback"
" string (optional)."
msgstr ""

#: ../../dev/repl.rst:117
msgid ""
"Each item in ``media`` is an array of two items: MIME-type and the data "
"string. Specific formats are defined and handled by the Backend.AI Media "
"module."
msgstr ""

#: ../../dev/repl.rst:120
msgid ""
"The ``options`` field may present optionally. If ``upload_output_files`` "
"is true (default), then the agent uploads the files generated by user "
"code in the working directory (``/home/work``) to AWS S3 bucket and make "
"their URLs available in the front-end."
msgstr ""

#: ../../dev/repl.rst:125
msgid "Writing PTY Mode Kernels"
msgstr ""

#: ../../dev/repl.rst:127
msgid ""
"If you want to allow users to have real-time interactions with your "
"kernel using web-based terminals, you should implement the PTY mode as "
"well. A good example is `our \"git\" kernel runner "
"<https://github.com/lablup/backend.ai-kernel-"
"runner/blob/master/src/ai/backend/kernel/git/__init__.py>`_."
msgstr ""

#: ../../dev/repl.rst:130
msgid ""
"The key concept is separation of the \"outer\" daemon and the \"inner\" "
"target program (e.g., a shell). The outer daemon should wrap the inner "
"program inside a pseudo-tty. As the outer daemon is completely hidden in "
"terminal interaction by the end-users, the programming language may "
"differ from the inner program. The challenge is that you need to "
"implement piping of ZeroMQ sockets from/to pseudo-tty file descriptors. "
"It is up to you how you implement the outer daemon, but if you choose "
"Python for it, we recommend to use asyncio or similar event loop "
"libraries such as tornado and Twisted to mulitplex sockets and file "
"descriptors for both input/output directions. When piping the messages, "
"the outer daemon should not apply any specific transformation; it should "
"send and receive all raw data/control byte sequences transparently "
"because the front-end (e.g., terminal.js) is responsible for interpreting"
" them. Currently we use PUB/SUB ZeroMQ socket types but this may change "
"later."
msgstr ""

#: ../../dev/repl.rst:138
msgid ""
"Optionally, you may run the query-mode loop side-by-side. For example, "
"our git kernel supports terminal resizing and pinging commands as the "
"query-mode inputs. There is no fixed specification for such commands yet,"
" but the current CodeOnWeb uses the followings:"
msgstr ""

#: ../../dev/repl.rst:142
#, python-format
msgid ""
"``%resize <rows> <cols>``: resize the pseudo-tty's terminal to fit with "
"the web terminal element in user browsers."
msgstr ""

#: ../../dev/repl.rst:143
msgid ""
"``%ping``: just a no-op command to prevent kernel idle timeouts while the"
" web terminal is open in user browsers."
msgstr ""

#: ../../dev/repl.rst:145
msgid ""
"A best practice (not mandatory but recommended) for PTY mode kernels is "
"to automatically respawn the inner program if it terminates (e.g., the "
"user has exited the shell) so that the users are not locked in a \"blank "
"screen\" terminal."
msgstr ""

#: ../../dev/repl.rst:151
msgid "Writing Custom Jail Policies"
msgstr ""

#: ../../dev/repl.rst:153
msgid ""
"Implement `the jail policy interface <https://github.com/lablup/backend"
".ai-jail>`_ in Go and ebmed it inside your jail build. Please give a look"
" to existing jail policies as good references."
msgstr ""

