{"version":3,"file":"static/js/2129.d08a4ec0.chunk.js","mappings":"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","sources":["../node_modules/.pnpm/@lezer+markdown@1.3.2/node_modules/@lezer/markdown/dist/index.js","../node_modules/.pnpm/@codemirror+lang-markdown@6.3.1/node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"Autolink\"] = 33] = \"Autolink\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n    Type[Type[\"URL\"] = 44] = \"URL\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length &&\n        cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// For reused nodes on gaps, we can't directly put the original\n        /// node into the tree, since that may be bigger than its parent.\n        /// When this happens, we create a dummy tree that is replaced by\n        /// the proper node in `injectGaps` @internal\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            for (let markI = 0;;) {\n                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;\n                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {\n                    let mark = line.markers[markI++];\n                    this.addNode(mark.type, mark.from, mark.to);\n                }\n                if (!next)\n                    break;\n                this.finishContext();\n            }\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{S}|\\\\p{P}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url) {\n            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [\n                elt(Type.LinkMark, start, start + 1),\n                // url[0] includes the closing bracket, so exclude it from this slice\n                elt(Type.URL, start + 1, start + url[0].length),\n                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)\n            ]));\n        }\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0 /* Mark.None */;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            // The destination and title must be separated by whitespace\n            if (pos != dest.to) {\n                title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n                if (title)\n                    pos = cx.skipSpace(title.to);\n            }\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    }\n    /// Returns true when there is an unmatched link or image opening\n    /// token before the current position.\n    get hasOpenLink() {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))\n                return true;\n        }\n        return false;\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    \"URL Autolink\": tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]{,100}@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.[\\w-]+)+(\\/[^\\s<]*)?/gy;\nconst lastTwoDomainWords = /[\\w-]+\\.[\\w-]+($|\\/)/;\nconst emailRE = /[\\w.+-]+@[\\w-]+(\\.[\\w.-]+)+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(\"_\") > -1)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/// Extension that implements autolinking for\n/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\n/// addresses.\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                if (pos && /\\w/.test(cx.text[pos - 1]))\n                    return -1;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && cx.hasOpenLink) {\n                        let noBracket = /([^\\[\\]]|\\[[^\\]]*\\])*/.exec(cx.text.slice(pos, end));\n                        end = pos + noBracket[0].length;\n                    }\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n/// [`Autolink`](#Autolink).\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n","import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null || isList(type) ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction isList(type) {\n    return type.name == \"OrderedList\" || type.name == \"BulletList\";\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [];\n    for (let cur = node; cur; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\n            nodes.push(cur);\n    }\n    let context = [];\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"FencedCode\") {\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\n        }\n        else if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(indentUnit) != \"\\t\")\n        return content;\n    let col = countColumn(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from, 0))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            let first = inner.node.firstChild, second = inner.node.getChild(\"ListItem\", \"ListItem\");\n            // Not second item or blank line before: delete a level of markup\n            if (first.to >= pos || second && second.to < pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move second item down, making tight two-item list non-tight\n                let insert = blankLine(context, state, line);\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        if (nonTightList(inner.node, state.doc))\n            insert = blankLine(context, state, line) + state.lineBreak + insert;\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction nonTightList(node, doc) {\n    if (node.name != \"OrderedList\" && node.name != \"BulletList\")\n        return false;\n    let first = node.firstChild, second = node.getChild(\"ListItem\", \"ListItem\");\n    if (!second)\n        return false;\n    let line1 = doc.lineAt(first.to), line2 = doc.lineAt(second.from);\n    let empty = /^[\\s>]*$/.test(line1.text);\n    return line1.number + (empty ? 0 : 1) < line2.number;\n}\nfunction blankLine(context, state, line) {\n    let insert = \"\";\n    for (let i = 0, e = context.length - 2; i <= e; i++) {\n        insert += context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null, i < e);\n    }\n    return normalizeIndent(insert, state);\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true, htmlTagLanguage = htmlNoMatch } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlTagLanguage.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlTagLanguage.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"names":["Type","CompositeBlock","create","type","value","from","parentHash","end","constructor","hash","children","positions","this","hashProp","NodeProp","contextHash","addChild","child","pos","prop","Tree","length","push","toTree","nodeSet","arguments","undefined","last","Math","max","types","balance","makeTree","NodeType","none","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","to","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","parser","leafBlockParsers","indexOf","DefaultLeafBlocks","SetextHeading","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","reusePlaceholders","Map","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","parsedPos","markI","mark","finishContext","reuseFragment","blockParsers","parse","lines","stop","endLeafBlock","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","toRelative","moveRangeI","parentType","scanLine","r","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","startComposite","getNodeType","addElement","injectMarks","top","addGaps","tree","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dummies","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","reuse","get","propValues","MarkdownParser","Parser","blockNames","inlineParsers","inlineNames","wrappers","super","nodeTypes","Object","t","name","id","createParse","w","configure","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","define","props","Array","isArray","Tag","NodeSet","extend","styleTags","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","Autolink","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","hasOpenLink","emp","closeSize","k","element","findOpeningDelimiter","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","dummy","set","is","abs","gapFrom","gapTo","markdownHighlighting","tags","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","n","leftOverSpace","nextPos","StrikethroughDelim","Strikethrough","strikethrough","parseRow","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","Table","heading","TaskParser","TaskList","atom","autolinkRE","urlRE","lastTwoDomainWords","emailRE","xmppResourceRE","autolinkEmailEnd","lastIndex","GFM","absPos","index","autolinkURLEnd","parseSubSuper","Superscript","special","Subscript","Emoji","match","data","defineLanguageFacet","commentTokens","headingProp","commonmark","foldNodeProp","add","isHeading","isList","state","doc","lineAt","indentNodeProp","languageDataProp","findSectionEnd","headerNode","level","headerIndent","foldService","of","syntaxTree","resolveInner","mkLang","Language","commonmarkLanguage","markdownLanguage","Context","spaceBefore","spaceAfter","item","blank","maxWidth","marker","number","String","itemNumber","getContext","context","replace","sliceString","renumberList","changes","prev","insert","normalizeIndent","facet","indentUnit","countColumn","insertNewlineContinueMarkup","_ref","dispatch","dont","changeByRange","range","empty","isActiveAt","emptyLine","second","getChild","delTo","EditorSelection","blankLine","lineBreak","prevLine","quoted","continued","charAt","line1","line2","nonTightList","update","scrollIntoView","userEvent","isMark","deleteMarkupBackward","_ref2","scan","childBefore","lastChild","contextNodeForDelete","spaceEnd","markdownKeymap","key","run","htmlNoMatch","html","matchClosingTags","markdown","codeLanguages","defaultCodeLanguage","addKeymap","completeHTMLTags","htmlTagLanguage","defaultCode","extensions","support","LanguageSupport","language","codeParser","languages","defaultLanguage","info","LanguageDescription","matchLanguageName","ParseContext","getSkippingParser","load","htmlParser","parseMixed","overlay","infoNode","parseCode","Prec","high","keymap","lang","autocomplete","htmlTagCompletion","sliceDoc","isTop","options","htmlTagCompletions","validFor","_tagCompletions","htmlCompletionSource","CompletionContext","EditorState"],"sourceRoot":""}