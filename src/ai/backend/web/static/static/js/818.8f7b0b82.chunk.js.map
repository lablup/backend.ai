{"version":3,"file":"static/js/818.8f7b0b82.chunk.js","mappings":"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","sources":["components/FileUploadManager.tsx"],"sourcesContent":["import { useSetBAINotification } from '../hooks/useBAINotification';\nimport { useFolderExplorerOpener } from './FolderExplorerOpener';\nimport { theme, Typography } from 'antd';\nimport { RcFile } from 'antd/es/upload';\nimport {\n  BAIFlex,\n  BAILink,\n  toLocalId,\n  useConnectedBAIClient,\n} from 'backend.ai-ui';\nimport { atom, useAtom, useSetAtom } from 'jotai';\nimport { atomFamily } from 'jotai/utils';\nimport _ from 'lodash';\nimport PQueue from 'p-queue';\nimport { useEffect, useRef } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { useSuspendedBackendaiClient } from 'src/hooks';\nimport { useBAISettingUserState } from 'src/hooks/useBAISetting';\nimport * as tus from 'tus-js-client';\n\ntype uploadStartFunction = (callbacks?: {\n  onProgress?: (\n    bytesUploaded: number,\n    bytesTotal: number,\n    fileName: string,\n  ) => void;\n}) => Promise<{ name: string; bytes: number }>;\n\ntype UploadRequest = {\n  vFolderId: string;\n  vFolderName: string;\n  uploadFileInfo: Array<{ file: RcFile; startFunction: uploadStartFunction }>;\n};\n\ntype UploadStatusInfo = {\n  vFolderName: string;\n  pendingFiles: Array<string>;\n  completedFiles: Array<string>;\n  failedFiles: Array<string>;\n  completedBytes: number;\n  totalExpectedSize: number;\n};\ntype UploadStatusMap = {\n  [vFolderId: string]: UploadStatusInfo;\n};\n\nconst uploadRequestAtom = atom<Array<UploadRequest>>([]);\nconst uploadStatusAtom = atom<UploadStatusMap>({});\nconst uploadStatusAtomFamily = atomFamily((vFolderId: string) => {\n  return atom(\n    (get) => get(uploadStatusAtom)[vFolderId],\n    (get, set, newStatus: UploadStatusInfo) => {\n      const prev = get(uploadStatusAtom);\n      set(uploadStatusAtom, {\n        ...prev,\n        [vFolderId]: newStatus,\n      });\n    },\n  );\n});\n\nconst useUploadStatusAtomStatus = (\n  vFolderId: string,\n): [UploadStatusInfo, (newStatus: UploadStatusInfo) => void] => {\n  return useAtom(uploadStatusAtomFamily(vFolderId));\n};\n\nconst FileUploadManager: React.FC = () => {\n  'use memo';\n\n  const { t } = useTranslation();\n  const { token } = theme.useToken();\n  const baiClient = useSuspendedBackendaiClient();\n  const { upsertNotification, closeNotification } = useSetBAINotification();\n  const { generateFolderPath } = useFolderExplorerOpener();\n  const [uploadRequests, setUploadRequests] = useAtom(uploadRequestAtom);\n  const [uploadStatus, setUploadStatus] = useAtom(uploadStatusAtom);\n  const [maxConcurrentUploads] = useBAISettingUserState(\n    'max_concurrent_uploads',\n  );\n  const queue = new PQueue({ concurrency: maxConcurrentUploads || 2 });\n\n  const pendingDeltaBytesRef = useRef<Record<string, number>>({});\n  const throttledUploadRequests = _.throttle(\n    (vFolderId: string, fileName: string) => {\n      const accumulatedDelta = pendingDeltaBytesRef.current[vFolderId] || 0;\n      pendingDeltaBytesRef.current[vFolderId] = 0;\n\n      setUploadStatus((prev) => {\n        const uploadedFilesCount = prev[vFolderId]?.completedFiles?.length || 0;\n        const totalUploadedFilesCount =\n          (prev[vFolderId]?.completedFiles?.length || 0) +\n          (prev[vFolderId]?.failedFiles?.length || 0) +\n          (prev[vFolderId]?.pendingFiles?.length || 0);\n\n        const totalExpectedSize = prev[vFolderId]?.totalExpectedSize || 0;\n        const currentCompletedBytes =\n          (prev[vFolderId]?.completedBytes || 0) + accumulatedDelta;\n\n        upsertNotification({\n          key: 'upload:' + vFolderId,\n          backgroundTask: {\n            status: 'pending',\n            percent:\n              totalExpectedSize > 0\n                ? (currentCompletedBytes / totalExpectedSize) * 100\n                : 0,\n            onChange: {\n              pending: {\n                description: (\n                  <BAIFlex direction=\"column\" align=\"start\">\n                    <Typography.Text>\n                      {t('explorer.UploadingFiles')} ( {uploadedFilesCount} /{' '}\n                      {totalUploadedFilesCount} )\n                    </Typography.Text>\n                    <Typography.Text\n                      ellipsis\n                      type=\"secondary\"\n                      style={{\n                        fontSize: token.fontSizeSM,\n                        maxWidth: '300px',\n                      }}\n                    >\n                      {fileName}\n                    </Typography.Text>\n                  </BAIFlex>\n                ),\n              },\n            },\n          },\n        });\n\n        return {\n          ...prev,\n          [vFolderId]: {\n            ...prev[vFolderId],\n            completedBytes: currentCompletedBytes,\n          },\n        };\n      });\n    },\n    200,\n    { leading: true, trailing: true },\n  );\n\n  useEffect(() => {\n    if (uploadRequests.length === 0 || !baiClient) return;\n\n    uploadRequests.forEach((uploadRequest) => {\n      const { vFolderId, vFolderName, uploadFileInfo } = uploadRequest;\n      const currUploadTotalSize = _.sumBy(\n        uploadFileInfo,\n        (info) => info.file.size,\n      );\n\n      setUploadStatus((prev) => {\n        const isFirstUpload = !prev[vFolderId];\n        const newTotalExpectedSize =\n          (prev[vFolderId]?.totalExpectedSize || 0) + currUploadTotalSize;\n        const currPct = isFirstUpload\n          ? 0\n          : ((prev[vFolderId]?.completedBytes || 0) / newTotalExpectedSize) *\n            100;\n\n        upsertNotification({\n          key: 'upload:' + vFolderId,\n          open: true,\n          message: (\n            <span>\n              {t('explorer.VFolder')}:&nbsp;\n              <BAILink\n                style={{\n                  fontWeight: 'normal',\n                }}\n                to={generateFolderPath(vFolderId)}\n                onClick={() => {\n                  closeNotification('upload:' + vFolderId);\n                }}\n              >{`${vFolderName}`}</BAILink>\n            </span>\n          ),\n          backgroundTask: {\n            status: 'pending',\n            percent: currPct,\n            onChange: {\n              pending: t('explorer.ProcessingUpload'),\n            },\n          },\n          duration: 0,\n        });\n\n        return {\n          ...prev,\n          [vFolderId]: {\n            vFolderName,\n            pendingFiles: [\n              ...(prev[vFolderId]?.pendingFiles || []),\n              ...uploadFileInfo.map(\n                (info) => info.file.webkitRelativePath || info.file.name,\n              ),\n            ],\n            completedFiles: prev[vFolderId]?.completedFiles || [],\n            failedFiles: prev[vFolderId]?.failedFiles || [],\n            completedBytes: prev[vFolderId]?.completedBytes || 0,\n            totalExpectedSize: newTotalExpectedSize,\n          },\n        };\n      });\n\n      uploadFileInfo.forEach(({ file, startFunction }) => {\n        queue.add(async () => {\n          // Capture fileName before any async operations\n          const fileName = file.webkitRelativePath || file.name;\n          let previousBytesUploaded = 0;\n\n          try {\n            await startFunction({\n              onProgress: (bytesUploaded, _bytesTotal, fileName) => {\n                // Since bytesUploaded is cumulative, calculate delta from previous value\n                const deltaBytes = bytesUploaded - previousBytesUploaded;\n                previousBytesUploaded = bytesUploaded;\n                pendingDeltaBytesRef.current[vFolderId] =\n                  (pendingDeltaBytesRef.current[vFolderId] || 0) + deltaBytes;\n\n                throttledUploadRequests(vFolderId, fileName);\n              },\n            });\n\n            // Success case\n            throttledUploadRequests.flush();\n            delete pendingDeltaBytesRef.current[vFolderId];\n\n            setUploadStatus((prev) => ({\n              ...prev,\n              [vFolderId]: {\n                ...prev[vFolderId],\n                pendingFiles: prev[vFolderId].pendingFiles.filter(\n                  (f: string) => f !== fileName,\n                ),\n                completedFiles: [\n                  ...(prev[vFolderId]?.completedFiles || []),\n                  fileName,\n                ],\n              },\n            }));\n          } catch (error) {\n            // Error case - use the captured fileName regardless of error structure\n            throttledUploadRequests.flush();\n            delete pendingDeltaBytesRef.current[vFolderId];\n\n            setUploadStatus((prev) => ({\n              ...prev,\n              [vFolderId]: {\n                ...prev[vFolderId],\n                pendingFiles: prev[vFolderId].pendingFiles.filter(\n                  (f: string) => f !== fileName,\n                ),\n                failedFiles: [\n                  ...(prev[vFolderId]?.failedFiles || []),\n                  fileName,\n                ],\n              },\n            }));\n          }\n        });\n      });\n    });\n    setUploadRequests([]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [uploadRequests]);\n\n  useEffect(() => {\n    Object.entries(uploadStatus).forEach(([vFolderId, status]) => {\n      if (!_.isEmpty(status?.pendingFiles)) return;\n\n      if (!_.isEmpty(status?.failedFiles)) {\n        upsertNotification({\n          key: 'upload:' + vFolderId,\n          open: true,\n          message: t('explorer.UploadFailed', {\n            folderName: status?.vFolderName,\n          }),\n          backgroundTask: {\n            status: 'rejected',\n            percent: 0,\n            onChange: {\n              rejected: t('explorer.FileUploadFailed', {\n                folderName: status?.vFolderName,\n              }),\n            },\n          },\n          extraDescription: _.join(status?.failedFiles, ', '),\n        });\n      } else if (!_.isEmpty(status?.completedFiles)) {\n        upsertNotification({\n          key: 'upload:' + vFolderId,\n          open: true,\n          message: (\n            <span>\n              {t('explorer.VFolder')}:&nbsp;\n              <BAILink\n                style={{\n                  fontWeight: 'normal',\n                }}\n                to={generateFolderPath(vFolderId)}\n                onClick={() => {\n                  closeNotification('upload:' + vFolderId);\n                }}\n              >{`${status?.vFolderName}`}</BAILink>\n            </span>\n          ),\n          backgroundTask: {\n            status: 'resolved',\n            percent: 100,\n            onChange: {\n              resolved: t('explorer.SuccessfullyUploadedToFolder'),\n            },\n          },\n          duration: 3,\n        });\n        setUploadStatus((prev) => ({\n          ...prev,\n          [vFolderId]: {\n            ...prev[vFolderId],\n            completedFiles: [],\n            completedBytes: 0,\n            totalExpectedSize: 0,\n          },\n        }));\n      }\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [uploadStatus]);\n\n  return null;\n};\n\nexport default FileUploadManager;\n\nexport const useFileUploadManager = (id?: string, folderName?: string) => {\n  'use memo';\n\n  const baiClient = useConnectedBAIClient();\n  const { t } = useTranslation();\n  const { upsertNotification } = useSetBAINotification();\n\n  const setUploadRequests = useSetAtom(uploadRequestAtom);\n\n  const [uploadStatus, setUploadStatus] = useUploadStatusAtomStatus(\n    id ? toLocalId(id) : '',\n  );\n\n  const validateUploadRequest = (\n    requestedFiles: Array<RcFile>,\n    vfolderId: string,\n  ) => {\n    const maxPossibleFileSize = baiClient._config.maxFileUploadSize;\n    const maxRequestFileSize = _.map(\n      requestedFiles,\n      (file) => file.size,\n    ).reduce((max, size) => Math.max(max, size), 0);\n\n    if (maxPossibleFileSize > 0 && maxRequestFileSize > maxPossibleFileSize) {\n      upsertNotification({\n        open: true,\n        key: 'upload:' + vfolderId,\n        message: t('explorer.UploadFailed', {\n          folderName: folderName ?? '',\n        }),\n        description: t('data.explorer.FileUploadSizeLimit'),\n        duration: 3,\n        toText: t('data.folders.OpenAFolder'),\n        to: {\n          search: new URLSearchParams({\n            folder: vfolderId,\n          }).toString(),\n        },\n      });\n      return false;\n    }\n    return true;\n  };\n\n  const uploadFiles = async (\n    files: RcFile[],\n    vfolderId: string,\n    currentPath: string,\n  ) => {\n    if (!validateUploadRequest(files, vfolderId)) return;\n\n    const fileToUpload: Array<RcFile> = [];\n    const startUploadFunctionMap = _.map(files, (file) => {\n      fileToUpload.push(file);\n      return async (callbacks?: {\n        onProgress?: (\n          bytesUploaded: number,\n          bytesTotal: number,\n          fileName: string,\n        ) => void;\n      }) => {\n        const fileName = file.webkitRelativePath || file.name;\n\n        try {\n          const uploadPath = [currentPath, fileName].filter(Boolean).join('/');\n\n          const uploadUrl: string =\n            await baiClient.vfolder.create_upload_session(\n              uploadPath,\n              file,\n              vfolderId,\n            );\n\n          return await new Promise<{ name: string; bytes: number }>(\n            (resolve, reject) => {\n              try {\n                const upload = new tus.Upload(file, {\n                  endpoint: uploadUrl,\n                  uploadUrl: uploadUrl,\n                  retryDelays: [0, 3000, 5000, 10000, 20000],\n                  chunkSize: getOptimalChunkSize(file.size),\n                  storeFingerprintForResuming: false, // Disable localStorage storage\n                  metadata: {\n                    filename: file.name,\n                    filetype: file.type,\n                  },\n                  onProgress: (bytesUploaded, bytesTotal) => {\n                    callbacks?.onProgress?.(\n                      bytesUploaded,\n                      bytesTotal,\n                      fileName,\n                    );\n                  },\n                  onSuccess: () => {\n                    resolve({\n                      name: fileName,\n                      bytes: file.size,\n                    });\n                  },\n                  onError: (_error) => {\n                    // Always reject with consistent structure\n                    reject(new Error(`Upload failed for ${fileName}`));\n                  },\n                });\n                upload.start();\n              } catch (error) {\n                // Handle synchronous errors from tus.Upload constructor or start()\n                reject(\n                  new Error(`Failed to initialize upload for ${fileName}`),\n                );\n              }\n            },\n          );\n        } catch (error) {\n          // Handle API errors or any other errors\n          // Always throw with a consistent error message\n          throw new Error(`Failed to prepare upload for ${fileName}`);\n        }\n      };\n    });\n\n    const uploadRequestInfo: UploadRequest = {\n      vFolderId: vfolderId,\n      vFolderName: folderName ?? '',\n      uploadFileInfo: _.zipWith(\n        fileToUpload,\n        startUploadFunctionMap,\n        (file, startFunction) => ({\n          file,\n          startFunction,\n        }),\n      ),\n    };\n    setUploadRequests((prev) => [...prev, uploadRequestInfo]);\n  };\n\n  return {\n    uploadStatus,\n    setUploadStatus,\n    uploadFiles,\n  };\n};\n\nconst getOptimalChunkSize = (fileSize: number): number => {\n  const MB = 1024 * 1024;\n\n  if (fileSize >= 5 * 1024 * MB) {\n    return 200 * MB;\n  } else if (fileSize >= 1 * 1024 * MB) {\n    return 100 * MB;\n  } else if (fileSize >= 100 * MB) {\n    return 50 * MB;\n  } else {\n    return 15 * MB;\n  }\n};\n"],"names":["uploadRequestAtom","atom","uploadStatusAtom","uploadStatusAtomFamily","atomFamily","vFolderId","get","set","newStatus","prev","FileUploadManager","t","useTranslation","token","theme","useToken","baiClient","useSuspendedBackendaiClient","upsertNotification","closeNotification","useSetBAINotification","generateFolderPath","useFolderExplorerOpener","uploadRequests","setUploadRequests","useAtom","uploadStatus","setUploadStatus","maxConcurrentUploads","useBAISettingUserState","queue","PQueue","concurrency","pendingDeltaBytesRef","useRef","throttledUploadRequests","_","fileName","accumulatedDelta","current","_prev$vFolderId","_prev$vFolderId$compl","_prev$vFolderId2","_prev$vFolderId2$comp","_prev$vFolderId3","_prev$vFolderId3$fail","_prev$vFolderId4","_prev$vFolderId4$pend","_prev$vFolderId5","_prev$vFolderId6","uploadedFilesCount","completedFiles","length","totalUploadedFilesCount","failedFiles","pendingFiles","totalExpectedSize","currentCompletedBytes","completedBytes","key","backgroundTask","status","percent","onChange","pending","description","_jsxs","BAIFlex","direction","align","children","Typography","Text","_jsx","ellipsis","type","style","fontSize","fontSizeSM","maxWidth","leading","trailing","useEffect","forEach","uploadRequest","vFolderName","uploadFileInfo","currUploadTotalSize","info","file","size","_prev$vFolderId7","_prev$vFolderId8","_prev$vFolderId9","_prev$vFolderId10","_prev$vFolderId11","_prev$vFolderId12","isFirstUpload","newTotalExpectedSize","currPct","open","message","BAILink","fontWeight","to","onClick","duration","map","webkitRelativePath","name","_ref","startFunction","add","async","previousBytesUploaded","onProgress","bytesUploaded","_bytesTotal","deltaBytes","flush","_prev$vFolderId13","filter","f","error","_prev$vFolderId14","Object","entries","_ref2","resolved","folderName","rejected","extraDescription","useFileUploadManager","id","$","_c","useConnectedBAIClient","useSetAtom","t0","toLocalId","t1","requestedFiles","vfolderId","maxPossibleFileSize","_config","maxFileUploadSize","maxRequestFileSize","_temp","reduce","_temp2","toText","search","URLSearchParams","folder","toString","validateUploadRequest","t2","files","vfolderId_0","currentPath","fileToUpload","startUploadFunctionMap","file_0","push","uploadPath","Boolean","join","uploadUrl","vfolder","create_upload_session","Promise","resolve","reject","tus","endpoint","retryDelays","chunkSize","getOptimalChunkSize","storeFingerprintForResuming","metadata","filename","filetype","bytesTotal","_callbacks$onProgress","callbacks","call","onSuccess","bytes","onError","_error","Error","start","t4","t3","uploadRequestInfo","_temp3","uploadFiles","fileSize","MB","max","Math","file_1"],"sourceRoot":""}