{"version":3,"file":"static/js/2217.237c745f.chunk.js","mappings":"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","sources":["../../node_modules/.pnpm/@codemirror+lang-angular@0.1.4/node_modules/@codemirror/lang-angular/dist/index.js","../../node_modules/.pnpm/@codemirror+lang-javascript@6.2.4/node_modules/@codemirror/lang-javascript/dist/index.js"],"sourcesContent":["import { LRLanguage, LanguageSupport } from '@codemirror/language';\nimport { html } from '@codemirror/lang-html';\nimport { javascriptLanguage } from '@codemirror/lang-javascript';\nimport { styleTags, tags } from '@lezer/highlight';\nimport { parseMixed } from '@lezer/common';\nimport { ExternalTokenizer, LRParser } from '@lezer/lr';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst Text = 1,\n  attributeContentSingle = 33,\n  attributeContentDouble = 34,\n  scriptAttributeContentSingle = 35,\n  scriptAttributeContentDouble = 36;\n\nconst text = /*@__PURE__*/new ExternalTokenizer(input => {\n    let start = input.pos;\n    for (;;) {\n        if (input.next == 10 /* Ch.Newline */) {\n            input.advance();\n            break;\n        }\n        else if (input.next == 123 /* Ch.BraceL */ && input.peek(1) == 123 /* Ch.BraceL */ || input.next < 0) {\n            break;\n        }\n        input.advance();\n    }\n    if (input.pos > start)\n        input.acceptToken(Text);\n});\nfunction attrContent(quote, token, script) {\n    return new ExternalTokenizer(input => {\n        let start = input.pos;\n        while (input.next != quote && input.next >= 0 &&\n            (script || input.next != 38 /* Ch.Ampersand */ && (input.next != 123 /* Ch.BraceL */ || input.peek(1) != 123 /* Ch.BraceL */)))\n            input.advance();\n        if (input.pos > start)\n            input.acceptToken(token);\n    });\n}\nconst attrSingle = /*@__PURE__*/attrContent(39 /* Ch.SingleQuote */, attributeContentSingle, false);\nconst attrDouble = /*@__PURE__*/attrContent(34 /* Ch.DoubleQuote */, attributeContentDouble, false);\nconst scriptAttrSingle = /*@__PURE__*/attrContent(39 /* Ch.SingleQuote */, scriptAttributeContentSingle, true);\nconst scriptAttrDouble = /*@__PURE__*/attrContent(34 /* Ch.DoubleQuote */, scriptAttributeContentDouble, true);\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = /*@__PURE__*/LRParser.deserialize({\n  version: 14,\n  states: \"(jOVOqOOOeQpOOOvO!bO'#CaOOOP'#Cx'#CxQVOqOOO!OQpO'#CfO!WQpO'#ClO!]QpO'#CrO!bQpO'#CsOOQO'#Cv'#CvQ!gQpOOQ!lQpOOQ!qQpOOOOOV,58{,58{O!vOpO,58{OOOP-E6v-E6vO!{QpO,59QO#TQpO,59QOOQO,59W,59WO#YQpO,59^OOQO,59_,59_O#_QpOOO#_QpOOO#gQpOOOOOV1G.g1G.gO#oQpO'#CyO#tQpO1G.lOOQO1G.l1G.lO#|QpO1G.lOOQO1G.x1G.xO$UO`O'#DUO$ZOWO'#DUOOQO'#Co'#CoQOQpOOOOQO'#Cu'#CuO$`OtO'#CwO$qOrO'#CwOOQO,59e,59eOOQO-E6w-E6wOOQO7+$W7+$WO%SQpO7+$WO%[QpO7+$WOOOO'#Cp'#CpO%aOpO,59pOOOO'#Cq'#CqO%fOpO,59pOOOS'#Cz'#CzO%kOtO,59cOOQO,59c,59cOOOQ'#C{'#C{O%|OrO,59cO&_QpO<<GrOOQO<<Gr<<GrOOQO1G/[1G/[OOOS-E6x-E6xOOQO1G.}1G.}OOOQ-E6y-E6yOOQOAN=^AN=^\",\n  stateData: \"&d~OvOS~OPROSQOVROWRO~OZTO[XO^VOaUOhWO~OR]OU^O~O[`O^aO~O[bO~O[cO~O[dO~ObeO~ObfO~ObgO~ORhO~O]kOwiO~O[lO~O_mO~OynOzoO~OysOztO~O[uO~O]wOwiO~O_yOwiO~OtzO~Os|O~OSQOV!OOW!OOr!OOy!QO~OSQOV!ROW!ROq!ROz!QO~O_!TOwiO~O]!UO~Oy!VO~Oz!VO~OSQOV!OOW!OOr!OOy!XO~OSQOV!ROW!ROq!ROz!XO~O]!ZO~O\",\n  goto: \"#dyPPPPPzPPPP!WPPPPP!WPP!Z!^!a!d!dP!g!j!m!p!v#Q#WPPPPPPPP#^SROSS!Os!PT!Rt!SRYPRqeR{nR}oRZPRqfR[PRqgQSOR_SQj`SvjxRxlQ!PsR!W!PQ!StR!Y!SQpeRrf\",\n  nodeNames: \"âš  Text Content }} {{ Interpolation InterpolationContent Entity InvalidEntity Attribute BoundAttributeName [ Identifier ] ( ) ReferenceName # Is ExpressionAttributeValue AttributeInterpolation AttributeInterpolation EventName DirectiveName * StatementAttributeValue AttributeName AttributeValue\",\n  maxTerm: 42,\n  nodeProps: [\n    [\"openedBy\", 3,\"{{\",15,\"(\"],\n    [\"closedBy\", 4,\"}}\",14,\")\"],\n    [\"isolate\", -4,5,19,25,27,\"\"]\n  ],\n  skippedNodes: [0],\n  repeatNodeCount: 4,\n  tokenData: \"0r~RyOX#rXY$mYZ$mZ]#r]^$m^p#rpq$mqr#rrs%jst&Qtv#rvw&hwx)zxy*byz*xz{+`{}#r}!O+v!O!P-]!P!Q#r!Q![+v![!]+v!]!_#r!_!`-s!`!c#r!c!}+v!}#O.Z#O#P#r#P#Q.q#Q#R#r#R#S+v#S#T#r#T#o+v#o#p/X#p#q#r#q#r0Z#r%W#r%W;'S+v;'S;:j-V;:j;=`$g<%lO+vQ#wTUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rQ$ZSO#q#r#r;'S#r;'S;=`$g<%lO#rQ$jP;=`<%l#rR$t[UQvPOX#rXY$mYZ$mZ]#r]^$m^p#rpq$mq#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR%qTyPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR&XTaPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR&oXUQWPOp'[pq#rq!]'[!]!^#r!^#q'[#q#r(d#r;'S'[;'S;=`)t<%lO'[R'aXUQOp'[pq#rq!]'[!]!^'|!^#q'[#q#r(d#r;'S'[;'S;=`)t<%lO'[R(TTVPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR(gXOp'[pq#rq!]'[!]!^'|!^#q'[#q#r)S#r;'S'[;'S;=`)t<%lO'[P)VUOp)Sq!])S!]!^)i!^;'S)S;'S;=`)n<%lO)SP)nOVPP)qP;=`<%l)SR)wP;=`<%l'[R*RTzPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR*iT^PUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR+PT_PUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR+gThPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR+}b[PUQO}#r}!O+v!O!Q#r!Q![+v![!]+v!]!c#r!c!}+v!}#R#r#R#S+v#S#T#r#T#o+v#o#q#r#q#r$W#r%W#r%W;'S+v;'S;:j-V;:j;=`$g<%lO+vR-YP;=`<%l+vR-dTwPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR-zTUQbPO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR.bTZPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR.xT]PUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR/^VUQO#o#r#o#p/s#p#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#rR/zTSPUQO#q#r#q#r$W#r;'S#r;'S;=`$g<%lO#r~0^TO#q#r#q#r0m#r;'S#r;'S;=`$g<%lO#r~0rOR~\",\n  tokenizers: [text, attrSingle, attrDouble, scriptAttrSingle, scriptAttrDouble, 0, 1],\n  topRules: {\"Content\":[0,2],\"Attribute\":[1,9]},\n  tokenPrec: 0\n});\n\nconst exprParser = /*@__PURE__*/javascriptLanguage.parser.configure({\n    top: \"SingleExpression\"\n});\nconst baseParser = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/styleTags({\n            Text: tags.content,\n            Is: tags.definitionOperator,\n            AttributeName: tags.attributeName,\n            \"AttributeValue ExpressionAttributeValue StatementAttributeValue\": tags.attributeValue,\n            Entity: tags.character,\n            InvalidEntity: tags.invalid,\n            \"BoundAttributeName/Identifier\": tags.attributeName,\n            \"EventName/Identifier\": /*@__PURE__*/tags.special(tags.attributeName),\n            \"ReferenceName/Identifier\": tags.variableName,\n            \"DirectiveName/Identifier\": tags.keyword,\n            \"{{ }}\": tags.brace,\n            \"( )\": tags.paren,\n            \"[ ]\": tags.bracket,\n            \"# '*'\": tags.punctuation\n        })\n    ]\n});\nconst exprMixed = { parser: exprParser }, statementMixed = { parser: javascriptLanguage.parser };\nconst textParser = /*@__PURE__*/baseParser.configure({\n    wrap: /*@__PURE__*/parseMixed((node, input) => node.name == \"InterpolationContent\" ? exprMixed : null),\n});\nconst attrParser = /*@__PURE__*/baseParser.configure({\n    wrap: /*@__PURE__*/parseMixed((node, input) => {\n        var _a;\n        return node.name == \"InterpolationContent\" ? exprMixed\n            : node.name != \"AttributeInterpolation\" ? null\n                : ((_a = node.node.parent) === null || _a === void 0 ? void 0 : _a.name) == \"StatementAttributeValue\" ? statementMixed : exprMixed;\n    }),\n    top: \"Attribute\"\n});\nconst textMixed = { parser: textParser }, attrMixed = { parser: attrParser };\nconst baseHTML = /*@__PURE__*/html({ selfClosingTags: true });\nfunction mkAngular(language) {\n    return language.configure({ wrap: parseMixed(mixAngular) }, \"angular\");\n}\n/**\nA language provider for Angular Templates.\n*/\nconst angularLanguage = /*@__PURE__*/mkAngular(baseHTML.language);\nfunction mixAngular(node, input) {\n    switch (node.name) {\n        case \"Attribute\":\n            return /^[*#(\\[]|\\{\\{/.test(input.read(node.from, node.to)) ? attrMixed : null;\n        case \"Text\":\n            return textMixed;\n    }\n    return null;\n}\n/**\nAngular Template language support.\n*/\nfunction angular(config = {}) {\n    let base = baseHTML;\n    if (config.base) {\n        if (config.base.language.name != \"html\" || !(config.base.language instanceof LRLanguage))\n            throw new RangeError(\"The base option must be the result of calling html(...)\");\n        base = config.base;\n    }\n    return new LanguageSupport(base.language == baseHTML.language ? angularLanguage : mkAngular(base.language), [base.support, base.language.data.of({\n            closeBrackets: { brackets: [\"[\", \"{\", '\"'] },\n            indentOnInput: /^\\s*[\\}\\]]$/\n        })]);\n}\n\nexport { angular, angularLanguage };\n","import { parser } from '@lezer/javascript';\nimport { syntaxTree, LRLanguage, indentNodeProp, continuedIndent, flatIndent, delimitedIndent, foldNodeProp, foldInside, defineLanguageFacet, sublanguageProp, LanguageSupport } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\n\n/**\nA collection of JavaScript-related\n[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).\n*/\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"function ${name}(${params}) {\\n\\t${}\\n}\", {\n        label: \"function\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for (let ${name} of ${collection}) {\\n\\t${}\\n}\", {\n        label: \"for\",\n        detail: \"of loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"do {\\n\\t${}\\n} while (${})\", {\n        label: \"do\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while (${}) {\\n\\t${}\\n}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try {\\n\\t${}\\n} catch (${error}) {\\n\\t${}\\n}\", {\n        label: \"try\",\n        detail: \"/ catch block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if (${}) {\\n\\t${}\\n} else {\\n\\t${}\\n}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name} {\\n\\tconstructor(${params}) {\\n\\t\\t${}\\n\\t}\\n}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import {${names}} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"named\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${name} from \\\"${module}\\\"\\n${}\", {\n        label: \"import\",\n        detail: \"default\",\n        type: \"keyword\"\n    })\n];\n/**\nA collection of snippet completions for TypeScript. Includes the\nJavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).\n*/\nconst typescriptSnippets = /*@__PURE__*/snippets.concat([\n    /*@__PURE__*/snippetCompletion(\"interface ${name} {\\n\\t${}\\n}\", {\n        label: \"interface\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"type ${name} = ${type}\", {\n        label: \"type\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"enum ${name} {\\n\\t${}\\n}\", {\n        label: \"enum\",\n        detail: \"definition\",\n        type: \"keyword\"\n    })\n]);\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Block\",\n    \"FunctionExpression\", \"FunctionDeclaration\", \"ArrowFunction\", \"MethodDeclaration\",\n    \"ForStatement\"\n]);\nfunction defID(type) {\n    return (node, def) => {\n        let id = node.node.getChild(\"VariableDefinition\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst functionContext = [\"FunctionDeclaration\"];\nconst gatherCompletions = {\n    FunctionDeclaration: /*@__PURE__*/defID(\"function\"),\n    ClassDeclaration: /*@__PURE__*/defID(\"class\"),\n    ClassExpression: () => true,\n    EnumDeclaration: /*@__PURE__*/defID(\"constant\"),\n    TypeAliasDeclaration: /*@__PURE__*/defID(\"type\"),\n    NamespaceDeclaration: /*@__PURE__*/defID(\"namespace\"),\n    VariableDefinition(node, def) { if (!node.matchContext(functionContext))\n        def(node, \"variable\"); },\n    TypeDefinition(node, def) { def(node, \"type\"); },\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (top) {\n            top = false;\n        }\n        else if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def) || ScopeNodes.has(node.name))\n                return false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\n    \"TemplateString\", \"String\", \"RegExp\",\n    \"LineComment\", \"BlockComment\",\n    \"VariableDefinition\", \"TypeDefinition\", \"Label\",\n    \"PropertyDefinition\", \"PropertyName\",\n    \"PrivatePropertyDefinition\", \"PrivatePropertyName\",\n    \"JSXText\", \"JSXAttributeValue\", \"JSXOpenTag\", \"JSXCloseTag\", \"JSXSelfClosingTag\",\n    \".\", \"?.\"\n];\n/**\nCompletion source that looks up locally defined names in\nJavaScript code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nfunction pathFor(read, member, name) {\n    var _a;\n    let path = [];\n    for (;;) {\n        let obj = member.firstChild, prop;\n        if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"VariableName\") {\n            path.push(read(obj));\n            return { path: path.reverse(), name };\n        }\n        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == \"MemberExpression\" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == \"PropertyName\") {\n            path.push(read(prop));\n            member = obj;\n        }\n        else {\n            return null;\n        }\n    }\n}\n/**\nHelper function for defining JavaScript completion sources. It\nreturns the completable name and object path for a completion\ncontext, or null if no name/property completion should happen at\nthat position. For example, when completing after `a.b.c` it will\nreturn `{path: [\"a\", \"b\"], name: \"c\"}`. When completing after `x`\nit will return `{path: [], name: \"x\"}`. When not in a property or\nname, it will return null if `context.explicit` is false, and\n`{path: [], name: \"\"}` otherwise.\n*/\nfunction completionPath(context) {\n    let read = (node) => context.state.doc.sliceString(node.from, node.to);\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (inner.name == \"PropertyName\") {\n        return pathFor(read, inner.parent, read(inner));\n    }\n    else if ((inner.name == \".\" || inner.name == \"?.\") && inner.parent.name == \"MemberExpression\") {\n        return pathFor(read, inner.parent, \"\");\n    }\n    else if (dontComplete.indexOf(inner.name) > -1) {\n        return null;\n    }\n    else if (inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {\n        return { path: [], name: read(inner) };\n    }\n    else if (inner.name == \"MemberExpression\") {\n        return pathFor(read, inner, \"\");\n    }\n    else {\n        return context.explicit ? { path: [], name: \"\" } : null;\n    }\n}\nfunction enumeratePropertyCompletions(obj, top) {\n    let options = [], seen = new Set;\n    for (let depth = 0;; depth++) {\n        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {\n            if (!/^[a-zA-Z_$\\xaa-\\uffdc][\\w$\\xaa-\\uffdc]*$/.test(name) || seen.has(name))\n                continue;\n            seen.add(name);\n            let value;\n            try {\n                value = obj[name];\n            }\n            catch (_) {\n                continue;\n            }\n            options.push({\n                label: name,\n                type: typeof value == \"function\" ? (/^[A-Z]/.test(name) ? \"class\" : top ? \"function\" : \"method\")\n                    : top ? \"variable\" : \"property\",\n                boost: -depth\n            });\n        }\n        let next = Object.getPrototypeOf(obj);\n        if (!next)\n            return options;\n        obj = next;\n    }\n}\n/**\nDefines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that\ncompletes from the given scope object (for example `globalThis`).\nWill enter properties of the object when completing properties on\na directly-named path.\n*/\nfunction scopeCompletionSource(scope) {\n    let cache = new Map;\n    return (context) => {\n        let path = completionPath(context);\n        if (!path)\n            return null;\n        let target = scope;\n        for (let step of path.path) {\n            target = target[step];\n            if (!target)\n                return null;\n        }\n        let options = cache.get(target);\n        if (!options)\n            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));\n        return {\n            from: context.pos - path.name.length,\n            options,\n            validFor: Identifier\n        };\n    };\n}\n\n/**\nA language provider based on the [Lezer JavaScript\nparser](https://github.com/lezer-parser/javascript), extended with\nhighlighting and indentation information.\n*/\nconst javascriptLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"javascript\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n                LabeledStatement: flatIndent,\n                SwitchBody: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                Block: /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                ArrowFunction: cx => cx.baseIndent + cx.unit,\n                \"TemplateString BlockComment\": () => null,\n                \"Statement Property\": /*@__PURE__*/continuedIndent({ except: /^\\s*{/ }),\n                JSXElement(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                JSXEscape(context) {\n                    let closed = /\\s*\\}/.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"JSXOpenTag JSXSelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            })\n        ]\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n        wordChars: \"$\"\n    }\n});\nconst jsxSublanguage = {\n    test: node => /^JSX/.test(node.name),\n    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n};\n/**\nA language provider for TypeScript.\n*/\nconst typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: \"ts\" }, \"typescript\");\n/**\nLanguage provider for JSX.\n*/\nconst jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n});\n/**\nLanguage provider for JSX + TypeScript.\n*/\nconst tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({\n    dialect: \"jsx ts\",\n    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]\n}, \"typescript\");\nlet kwCompletion = (name) => ({ label: name, type: \"keyword\" });\nconst keywords = /*@__PURE__*/\"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(kwCompletion);\nconst typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/[\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(kwCompletion));\n/**\nJavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)\nand local variable completion.\n*/\nfunction javascript(config = {}) {\n    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)\n        : config.typescript ? typescriptLanguage : javascriptLanguage;\n    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);\n    return new LanguageSupport(lang, [\n        javascriptLanguage.data.of({\n            autocomplete: ifNotIn(dontComplete, completeFromList(completions))\n        }),\n        javascriptLanguage.data.of({\n            autocomplete: localCompletionSource\n        }),\n        config.jsx ? autoCloseTags : [],\n    ]);\n}\nfunction findOpenTag(node) {\n    for (;;) {\n        if (node.name == \"JSXOpenTag\" || node.name == \"JSXSelfClosingTag\" || node.name == \"JSXFragmentTag\")\n            return node;\n        if (node.name == \"JSXEscape\" || !node.parent)\n            return null;\n        node = node.parent;\n    }\n}\nfunction elementName(doc, tree, max = doc.length) {\n    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {\n        if (ch.name == \"JSXIdentifier\" || ch.name == \"JSXBuiltin\" || ch.name == \"JSXNamespacedName\" ||\n            ch.name == \"JSXMemberExpression\")\n            return doc.sliceString(ch.from, Math.min(ch.to, max));\n    }\n    return \"\";\n}\nconst android = typeof navigator == \"object\" && /*@__PURE__*//Android\\b/.test(navigator.userAgent);\n/**\nExtension that will automatically insert JSX close tags when a `>` or\n`/` is typed.\n*/\nconst autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {\n    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly ||\n        from != to || (text != \">\" && text != \"/\") ||\n        !javascriptLanguage.isActiveAt(view.state, from, -1))\n        return false;\n    let base = defaultInsert(), { state } = base;\n    let closeTags = state.changeByRange(range => {\n        var _a;\n        let { head } = range, around = syntaxTree(state).resolveInner(head - 1, -1), name;\n        if (around.name == \"JSXStartTag\")\n            around = around.parent;\n        if (state.doc.sliceString(head - 1, head) != text || around.name == \"JSXAttributeValue\" && around.to > head) ;\n        else if (text == \">\" && around.name == \"JSXFragmentTag\") {\n            return { range, changes: { from: head, insert: `</>` } };\n        }\n        else if (text == \"/\" && around.name == \"JSXStartCloseTag\") {\n            let empty = around.parent, base = empty.parent;\n            if (base && empty.from == head - 2 &&\n                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"JSXFragmentTag\")) {\n                let insert = `${name}>`;\n                return { range: EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };\n            }\n        }\n        else if (text == \">\") {\n            let openTag = findOpenTag(around);\n            if (openTag && openTag.name == \"JSXOpenTag\" &&\n                !/^\\/?>|^<\\//.test(state.doc.sliceString(head, head + 2)) &&\n                (name = elementName(state.doc, openTag, head)))\n                return { range, changes: { from: head, insert: `</${name}>` } };\n        }\n        return { range };\n    });\n    if (closeTags.changes.empty)\n        return false;\n    view.dispatch([\n        base,\n        state.update(closeTags, { userEvent: \"input.complete\", scrollIntoView: true })\n    ]);\n    return true;\n});\n\n/**\nConnects an [ESLint](https://eslint.org/) linter to CodeMirror's\n[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the\n[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)\nclass, and `config` an optional ESLint configuration. The return\nvalue of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)\nto create a JavaScript linting extension.\n\nNote that ESLint targets node, and is tricky to run in the\nbrowser. The\n[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)\npackage may help with that (see\n[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).\n*/\nfunction esLint(eslint, config) {\n    if (!config) {\n        config = {\n            parserOptions: { ecmaVersion: 2019, sourceType: \"module\" },\n            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },\n            rules: {}\n        };\n        eslint.getRules().forEach((desc, name) => {\n            var _a;\n            if ((_a = desc.meta.docs) === null || _a === void 0 ? void 0 : _a.recommended)\n                config.rules[name] = 2;\n        });\n    }\n    return (view) => {\n        let { state } = view, found = [];\n        for (let { from, to } of javascriptLanguage.findRegions(state)) {\n            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };\n            for (let d of eslint.verify(state.sliceDoc(from, to), config))\n                found.push(translateDiagnostic(d, state.doc, offset));\n        }\n        return found;\n    };\n}\nfunction mapPos(line, col, doc, offset) {\n    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);\n}\nfunction translateDiagnostic(input, doc, offset) {\n    let start = mapPos(input.line, input.column, doc, offset);\n    let result = {\n        from: start,\n        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,\n        message: input.message,\n        source: input.ruleId ? \"eslint:\" + input.ruleId : \"eslint\",\n        severity: input.severity == 1 ? \"warning\" : \"error\",\n    };\n    if (input.fix) {\n        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;\n        result.actions = [{\n                name: \"fix\",\n                apply(view, start) {\n                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });\n                }\n            }];\n    }\n    return result;\n}\n\nexport { autoCloseTags, completionPath, esLint, javascript, javascriptLanguage, jsxLanguage, localCompletionSource, scopeCompletionSource, snippets, tsxLanguage, typescriptLanguage, typescriptSnippets };\n"],"names":["text","ExternalTokenizer","input","start","pos","next","advance","peek","acceptToken","attrContent","quote","token","script","attrSingle","attrDouble","scriptAttrSingle","scriptAttrDouble","parser","LRParser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","nodeProps","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","tokenPrec","exprParser","javascriptLanguage","configure","top","baseParser","props","styleTags","Text","tags","content","Is","definitionOperator","AttributeName","attributeName","attributeValue","Entity","character","InvalidEntity","invalid","special","variableName","keyword","brace","paren","bracket","punctuation","exprMixed","statementMixed","textMixed","wrap","parseMixed","node","name","attrMixed","_a","parent","baseHTML","html","selfClosingTags","mkAngular","language","mixAngular","angularLanguage","test","read","from","to","angular","config","arguments","length","undefined","base","LRLanguage","RangeError","LanguageSupport","support","data","of","closeBrackets","brackets","indentOnInput","snippets","snippetCompletion","label","detail","type","typescriptSnippets","concat","cache","NodeWeakMap","ScopeNodes","Set","defID","def","id","getChild","functionContext","gatherCompletions","FunctionDeclaration","ClassDeclaration","ClassExpression","EnumDeclaration","TypeAliasDeclaration","NamespaceDeclaration","VariableDefinition","matchContext","TypeDefinition","__proto__","getScope","doc","cached","get","completions","sliceString","push","cursor","IterMode","IncludeAnonymous","iterate","gather","has","c","set","Identifier","dontComplete","localCompletionSource","context","inner","syntaxTree","state","resolveInner","indexOf","isWord","sliceDoc","explicit","options","validFor","pathFor","member","path","prop","obj","firstChild","reverse","lastChild","completionPath","scopeCompletionSource","scope","Map","target","step","seen","depth","Object","getOwnPropertyNames","keys","value","add","_","boost","getPrototypeOf","enumeratePropertyCompletions","define","indentNodeProp","IfStatement","continuedIndent","except","TryStatement","LabeledStatement","flatIndent","SwitchBody","after","textAfter","closed","isCase","baseIndent","unit","Block","delimitedIndent","closing","ArrowFunction","cx","TemplateString BlockComment","JSXElement","lineIndent","JSXEscape","column","foldNodeProp","foldInside","BlockComment","tree","languageData","commentTokens","line","block","open","close","wordChars","jsxSublanguage","facet","defineLanguageFacet","typescriptLanguage","dialect","jsxLanguage","sublanguageProp","n","isTop","tsxLanguage","kwCompletion","keywords","split","map","typescriptKeywords","javascript","lang","jsx","typescript","autocomplete","ifNotIn","completeFromList","autoCloseTags","elementName","max","ch","nextSibling","Math","min","android","navigator","userAgent","EditorView","inputHandler","view","defaultInsert","composing","compositionStarted","readOnly","isActiveAt","closeTags","changeByRange","range","head","around","changes","insert","empty","EditorSelection","openTag","findOpenTag","dispatch","update","userEvent","scrollIntoView","esLint","eslint","parserOptions","ecmaVersion","sourceType","env","browser","es6","es2015","es2017","es2020","rules","getRules","forEach","desc","meta","docs","recommended","found","findRegions","fromLine","lineAt","offset","number","col","d","verify","translateDiagnostic","mapPos","result","endLine","endColumn","message","source","ruleId","severity","fix","actions","apply"],"sourceRoot":""}